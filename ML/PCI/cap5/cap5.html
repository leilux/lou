<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>优化 | 机器学习</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.1.0">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../../PCI/cap6/cap6.html" />
    
    
    <link rel="prev" href="../../PCI/cap4/cap4.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../../gitbook/style.css">


        
    <div class="book" data-level="1.4" data-basepath="../.." data-revision="1428042646490">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="PCI/readme.html">
            
                
                    <a href="../../PCI/readme.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         集体智慧编程
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="PCI/cap2/cap2.html">
            
                
                    <a href="../../PCI/cap2/cap2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         提供推荐
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="PCI/cap3/cap3.html">
            
                
                    <a href="../../PCI/cap3/cap3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         发现群组
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.3" data-path="PCI/cap4/cap4.html">
            
                
                    <a href="../../PCI/cap4/cap4.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.3.</b>
                        
                         搜索与排名
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="1.4" data-path="PCI/cap5/cap5.html">
            
                
                    <a href="../../PCI/cap5/cap5.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.4.</b>
                        
                         优化
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.5" data-path="PCI/cap6/cap6.html">
            
                
                    <a href="../../PCI/cap6/cap6.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.5.</b>
                        
                         文档过滤
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.6" data-path="PCI/cap7/cap7.html">
            
                
                    <a href="../../PCI/cap7/cap7.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.6.</b>
                        
                         决策树建模
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.7" data-path="PCI/cap8/cap8.html">
            
                
                    <a href="../../PCI/cap8/cap8.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.7.</b>
                        
                         构建价格模型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.8" data-path="PCI/cap9/cap9.html">
            
                
                    <a href="../../PCI/cap9/cap9.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.8.</b>
                        
                         高阶分类：核心方法和SVMs
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.9" data-path="PCI/cap10/cap10.html">
            
                
                    <a href="../../PCI/cap10/cap10.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.9.</b>
                        
                         寻找独立特征
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.10" data-path="PCI/cap11/cap11.html">
            
                
                    <a href="../../PCI/cap11/cap11.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.10.</b>
                        
                         智能进化
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.11" data-path="PCI/cap12/cap12.html">
            
                
                    <a href="../../PCI/cap12/cap12.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.11.</b>
                        
                         算法总结
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../" >机器学习</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_7">
                    
                        <h2 id="----optimization">优化 -- optimization</h2>
<p>本章使用一系列被称为<strong>随机优化</strong>（stochatic optimization）的技术来解决协作类问题。
优化技术擅长于处理：受多种变量的影响，存在许多可能解的问题，以及结果因这些变量的组合而产生很大变化的问题。
优化技术的应用：
物理学中：研究分支运动
生物学中：预测蛋白质结构
计算机科学中；预测算法的最坏可能运行时间</p>
<p>原理：优化算法通过尝试许多不同题解并给这些题解打分以确定其质量的方式来找到一个问题的最优解。
应用场景：存在大量可能的题解以至于我们无法对它们进行一一尝试的情况。以一种对题解可能有改进的方式来对其进行智能化地修正。</p>
<p>例子：无法将输入用一个简单的公式映射到输出，所以要想找到最优解，就必须借助与优化算法</p>
<ol>
<li>制定组团旅游计划：
输入：
每个人的航班时间表
须要租用多少辆汽车
哪个飞机场是最通畅的
输出：
总的成本、侯机的时间、起飞的时间</li>
<li>如何基于人们的偏好来分配有限的资源？</li>
<li>如何用最少的交叉线来可视化社会网络？</li>
</ol>
<h3 id="----group-travel">组团旅游 -- Group Travel</h3>
<p>为来自不同地方去往同一地点的人们安排一次旅游是一件极富挑战性的事情。
要求：家庭成员来自全国各地，他们希望在纽约会面。他们将在同一天到达，并在同一天离开，而且他们想搭乘相同的交通工具往返飞机场。
每天有许多航班从任何一位家庭成员的所在地飞往纽约，飞机起飞时间是不同的，价格和续航时间上也都不尽相同。</p>
<pre><code class="lang-python"><span class="hljs-comment"># optimization.py</span>
<span class="hljs-keyword">import</span> time
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> math

people = [
    (<span class="hljs-string">'Seymour'</span>, <span class="hljs-string">'BOS'</span>),
    (<span class="hljs-string">'Franny'</span>, <span class="hljs-string">'DAL'</span>),
    (<span class="hljs-string">'Zooey'</span>, <span class="hljs-string">'CAK'</span>),
    (<span class="hljs-string">'Walt'</span>, <span class="hljs-string">'MIA'</span>),
    (<span class="hljs-string">'Buddy'</span>, <span class="hljs-string">'ORD'</span>),
    (<span class="hljs-string">'Les'</span>, <span class="hljs-string">'OMA'</span>),
]

destination = <span class="hljs-string">'LGA'</span>

flights = {}
<span class="hljs-comment">#</span>
<span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file(<span class="hljs-string">'schedule.txt'</span>):
    origin, dest, depart, arrive, price = line.strip().split(<span class="hljs-string">','</span>)
    flights.setdefault((origin, dest), [])

    <span class="hljs-comment"># 将航班详情添加到航班列表中</span>
    flights[(origin, dest)].append((depart, arrive, int(price)))

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getminutes</span><span class="hljs-params">(t)</span>:</span>
    x = time.strptime(t, <span class="hljs-string">'%H:%M'</span>)
    <span class="hljs-keyword">return</span> x[<span class="hljs-number">3</span>]*<span class="hljs-number">60</span>+x[<span class="hljs-number">4</span>]
</code></pre>
<h3 id="----respresenting-solutions">描述题解 -- Respresenting Solutions</h3>
<p>使用数字序列描述题解：一个数字可以代表某人选择乘坐的航班--0是这天中的第一次航班，1是第二次...。因为每个人都需要往返两个航班，所以列表的长度是人数的两倍。</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printschedule</span><span class="hljs-params">(r)</span>:</span>
    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> range(len(r)/<span class="hljs-number">2</span>):
        name = people[d][<span class="hljs-number">0</span>]
        origin = people[d][<span class="hljs-number">1</span>]
        out = flights[(origin, destination)][r[<span class="hljs-number">2</span>*d]]
        ret = flights[(destination, origin)][r[<span class="hljs-number">2</span>*d+<span class="hljs-number">1</span>]]
        <span class="hljs-keyword">print</span> <span class="hljs-string">'%10s%10s %5s-%5s $%3s %5s-%5s $%3s'</span> % (
                name, origin, out[<span class="hljs-number">0</span>], out[<span class="hljs-number">1</span>], out[<span class="hljs-number">2</span>], ret[<span class="hljs-number">0</span>], ret[<span class="hljs-number">1</span>], ret[<span class="hljs-number">2</span>])
</code></pre>
<pre><code class="lang-python"><span class="hljs-comment">#print '打印航班'</span>
<span class="hljs-comment">#s = [1,4,3,2,7,3,6,3,2,4,5,3]</span>
<span class="hljs-comment">#printschedule(s)</span>
</code></pre>
<h3 id="----the-cost-function">成本函数 -- The Cost Function</h3>
<p><strong>成本函数</strong>是用优化算法解决问题的关键，它通常是最难确定的。成本函数需要返回一个值用以表示方案的好坏。对于<strong>好坏的程度</strong>没有特定的衡量尺度，唯一的要求就是函数返回的值越大，表示该方案越差。</p>
<p>通常根据从多变量来鉴别方案的好坏是比较困难的。我们来考查一些在组团旅游的例子中能被度量的变量：
价格：所有航班的总票价，或者有可能是考虑财务因素之后的加权平均
旅行时间：每个人在飞机上花费的时间
等待时间：在机场等待其他成员到达的时间
出发时间：早晨太早起飞的航班也许会产生额外的成本，因为这要求旅行者减少睡眠的时间
汽车租用时间：超过24小时要多符一天的租金</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">schedulecost</span><span class="hljs-params">(sol)</span>:</span>
    totalprice = <span class="hljs-number">0</span>
    lastestarrival = <span class="hljs-number">0</span>
    earliestdep = <span class="hljs-number">24</span> * <span class="hljs-number">60</span>

    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> range(len(sol)/<span class="hljs-number">2</span>):
        <span class="hljs-comment"># 得到往程和返程航班</span>
        origin = people[d][<span class="hljs-number">1</span>]
        outbound = flights[(origin, destination)][int(sol[<span class="hljs-number">2</span>*d])]
        returnf = flights[(destination, origin)][int(sol[<span class="hljs-number">2</span>*d+<span class="hljs-number">1</span>])]

        <span class="hljs-comment"># 总价格等于所有往程航班和返程航班价格之和</span>
        totalprice += outbound[<span class="hljs-number">2</span>]
        totalprice += returnf[<span class="hljs-number">2</span>]

        <span class="hljs-comment"># 记录最晚到达时间和最早离开时间</span>
        <span class="hljs-keyword">if</span> lastestarrival &lt; getminutes(outbound[<span class="hljs-number">1</span>]): lastestarrival = getminutes(outbound[<span class="hljs-number">1</span>])
        <span class="hljs-keyword">if</span> earliestdep &gt; getminutes(returnf[<span class="hljs-number">0</span>]): earliestdep = getminutes(returnf[<span class="hljs-number">0</span>])
    <span class="hljs-comment"># 每个人必须在机场等待直到最后一个人到达为止</span>
    <span class="hljs-comment"># 他们也必须在相同时间到达，并等候他们的返程航班</span>
    totalwait = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> range(len(sol)/<span class="hljs-number">2</span>):
        origin = people[d][<span class="hljs-number">1</span>]
        outbound = flights[(origin, destination)][int(sol[<span class="hljs-number">2</span>*d])]
        returnf = flights[(destination, origin)][int(sol[<span class="hljs-number">2</span>*d+<span class="hljs-number">1</span>])]
        totalwait += lastestarrival - getminutes(outbound[<span class="hljs-number">1</span>])
        totalwait += getminutes(returnf[<span class="hljs-number">0</span>]) - earliestdep
    <span class="hljs-comment"># 这个题解要求多付一天的汽车租用费用吗？如果是，费用为50美元</span>
    <span class="hljs-comment"># 书上似乎有误 &gt;</span>
    <span class="hljs-keyword">if</span> lastestarrival &lt; earliestdep: totalprice += <span class="hljs-number">50</span>

    <span class="hljs-keyword">return</span> totalprice + totalwait
</code></pre>
<p>成本函数建立后，我们的目标就是要通过选择正确的数字序列来最小化该成本。理论上我们可以尝试10^12种组合确保我们得到最优的答案，但是这会花费非常长的时间。</p>
<h3 id="----random-searching">随机搜索 -- Random Searching</h3>
<p>随机搜索不是一种非常好的优化算法，但是它却使我们很容易领会所有算法的真正意图，并且也是我们评估其他算法优劣的基线（baseline）</p>
<p>此函数会随机产生1000次猜测，并对每一次猜测调用costf。它会跟踪最佳猜测并将结果返回。</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">randomoptimize</span><span class="hljs-params">(domain, costf)</span>:</span>
    <span class="hljs-string">'''Domain是由一个二元组构成的列表，指定了每个变量的最小最大值
    costf成本函数
    '''</span>
    best = <span class="hljs-number">999999999</span>
    bestr = <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):
        <span class="hljs-comment"># 创建一个随机解</span>
        r = [random.randint(domain[i][<span class="hljs-number">0</span>], domain[i][<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(domain))]
        <span class="hljs-comment"># 得到成本</span>
        cost = costf(r)
        <span class="hljs-comment"># 与到目前为止的最优解进行比较</span>
        <span class="hljs-keyword">if</span> cost &lt; best:
            best = cost
            bestr = r
    <span class="hljs-keyword">return</span> r
</code></pre>
<pre><code class="lang-python"><span class="hljs-keyword">print</span> <span class="hljs-string">'随机搜索'</span>
domain = [(<span class="hljs-number">0</span>,<span class="hljs-number">9</span>)]*(len(people)*<span class="hljs-number">2</span>)
s = randomoptimize(domain, schedulecost)
schedulecost(s)
printschedule(s)
</code></pre>
<p>缺点：尝试各种题解是非常低效的，因为这种方式没有充分利用已经发现的优解。</p>
<h3 id="----hill-climbing">爬山法 -- Hill Climbing</h3>
<p>爬山法：随机搜索的一个替代方法。以一个随机解开始，然后在其临近的解集中寻找更好的题解（具有更低的成本）。类似从斜坡上向下走。</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hillclimb</span><span class="hljs-params">(domain, costf)</span>:</span>
    <span class="hljs-comment"># 创建一个随机解</span>
    sol = [random.randint(domain[i][<span class="hljs-number">0</span>], domain[i][<span class="hljs-number">1</span>])
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(domain))]
    <span class="hljs-comment"># 主循环</span>
    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:
        <span class="hljs-comment"># 创建相邻解的列表</span>
        neighbors = []
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(domain)):
            <span class="hljs-comment"># 在每个方向上相对于原值偏离一点</span>
            <span class="hljs-keyword">if</span> sol[j] &gt; domain[j][<span class="hljs-number">0</span>]:
                neighbors.append(sol[<span class="hljs-number">0</span>:j]+[sol[j]-<span class="hljs-number">1</span>]+so[j+<span class="hljs-number">1</span>:])
            <span class="hljs-keyword">if</span> sol[j] &lt; domain[j][<span class="hljs-number">1</span>]:
                neighbors.append(sol[<span class="hljs-number">0</span>:j]+[sol[j]+<span class="hljs-number">1</span>]+so[j+<span class="hljs-number">1</span>:])
        <span class="hljs-comment"># 在相邻解中寻找最优解</span>
        current = costf(sol)
        best = current
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(neighbors)):
            cost = costf(neighbors[j])
            <span class="hljs-keyword">if</span> cost &lt; best:
                best = cost
                sol = neighbors[j]

        <span class="hljs-comment"># 如果没有更好的解，则退出循环</span>
        <span class="hljs-keyword">if</span> best == current:
            <span class="hljs-keyword">break</span>

    <span class="hljs-keyword">return</span> sol
</code></pre>
<p>该函数在给定域内随机生成一个数字列表，用以构造初始的题解。它通过循环遍历列表中的每一个元素，找到当前解的所有相邻题解，然后创建出两个新的列表：一个列表中的元素加1，另一个列表中的元素减1.相邻解中最优的一个将成为新的当前题解。</p>
<pre><code class="lang-python"><span class="hljs-keyword">print</span> <span class="hljs-string">'爬山法'</span>
s = hillclimb(domain, schedulecost)
schedulecost(s)
printschedule(s)
</code></pre>
<p>简单地从斜坡滑下不一定产生全局最优解。最后的解会是一个局部范围内的最小值，它比邻近解的表现都好，但却不是全局最优的。
解决这一难题的一种方法被成为<strong>随机重复爬山法</strong>（random-restart hill climbing）
还有模拟退火算法和遗传算法</p>
<h3 id="----simulated-annealing">模拟退火算法 -- Simulated Annealing</h3>
<p>模拟退火算法：受物理学领域启发而来的一种优化算法。退火是指将合金加热后再慢慢冷却的过程。大量的原子因为受到激发而向周围跳跃，然后有逐渐稳定到一个低能阶的状态，所以这些原子能够找到一个低能阶的配置（configuration）</p>
<p>算法的关键部分在于： 如果新的成本值更低，则新的题解就会成为当前题解，这和爬山法非常相似。不过，如果成本值更高的话，则新的题解仍将可能成为当前题解，这是避免局部最小值问题的一种尝试。
较差解被接受的概率为p=e^(-(highcost-lowcost)/temperature)
模拟退火算法之所以管用，因为它在退火过程的开始阶段会接受变现较差的解。随着退火过程的不断进行，算法越来越不可能接受较差的解，直到最后，它只会接受更优的解。</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">annealingoptimize</span><span class="hljs-params">(domain, costf, T=<span class="hljs-number">10000.0</span>, cool=<span class="hljs-number">0.95</span>, step=<span class="hljs-number">1</span>)</span>:</span>
    <span class="hljs-comment"># 随机初始化值</span>
    vec = [float(random.randint(domain[i][<span class="hljs-number">0</span>], domain[i][<span class="hljs-number">1</span>])) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(domain))]

    <span class="hljs-keyword">while</span> T&gt;<span class="hljs-number">0.1</span>:
        <span class="hljs-comment"># 选择一个索引值</span>
        i = random.randint(<span class="hljs-number">0</span>, len(domain)-<span class="hljs-number">1</span>)

        <span class="hljs-comment"># 选择一个改变索引值的方向</span>
        dir = random.randint(-step, step)
        <span class="hljs-comment"># 创建一个代表题解的新列表，改变其中一个值</span>
        vecb = vec[:]
        vecb[i] += dir
        <span class="hljs-keyword">if</span> vecb[i] &lt; domain[i][<span class="hljs-number">0</span>]: vecb[i] = domain[i][<span class="hljs-number">0</span>]
        <span class="hljs-keyword">elif</span> vecb[i] &gt; domain[i][<span class="hljs-number">1</span>]: vecb[i] = domain[i][<span class="hljs-number">1</span>]
        <span class="hljs-comment"># 计算当前成本和新的成本</span>
        ea = costf(vec)
        eb = costf(vecb)

        <span class="hljs-comment"># 它是更好的解吗？或者是趋向最优解的可能的临界解吗？</span>
        <span class="hljs-keyword">if</span> (eb&lt;ea <span class="hljs-keyword">or</span> random.random()&lt;pow(math.e, -(eb-ea)/T)):
            vec = vecb

        <span class="hljs-comment"># 降低温度</span>
        T = T * cool
    <span class="hljs-keyword">return</span> vec
</code></pre>
<pre><code>print &#39;模拟退火算法&#39;
s = annealingoptimize(domain, schedulecost)
schedulecost(s)
printschedule(s)
</code></pre><h3 id="----genetic-algorithms">遗传算法 -- Genetic Algorithms</h3>
<p>遗传算法：受自然科学的启发，运行过程是先随机生成一组解，称之为<strong>种群</strong>（population）。在优化过程的每一步，算法会计算整个种群的成本函数，从而得到一个有关题解的有序列表。
在对题解进行排序之后，一个新的种群--我们称之为下一代被创建出来了。首先，进行**精英选拔法（elitism）：将但前种群中位于最顶端的题解加入其所在的新种群中。余下部分是有修改最优解后形成的全新解组成的。
两种修改题解的方法:
变异（mutation）：对一个既有解进行微小的、简单的、随机的改变。
交叉（crossover）或配对（breeding）：选取最有解中的两个解，然后将它们按某种方式进行结合。
一个新的种群是通过对最优解进行随机的变异和配对处理构造出来的，它的大小通常与旧的种群相同。尔后，这一过程会一直重复进行。达到指定的迭代次数，或者连续经过数代后题解都没有得到改善，整个过程就结束了。</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">geneticoptimize</span><span class="hljs-params">(domain, costf, popsize=<span class="hljs-number">50</span>, step=<span class="hljs-number">1</span>, mutprob=<span class="hljs-number">0.2</span>, elite=<span class="hljs-number">0.2</span>, maxiter=<span class="hljs-number">100</span>)</span>:</span>
    <span class="hljs-string">'''popsize:种群大小，mutprob:种群的新成员是由变异而非交叉得来的概率
    elite:种群中被认为是优解且被允许传入下一代的部分
    maxiter:需运行多少代
    '''</span>
    <span class="hljs-comment"># 变异(mutation)操作</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutate</span><span class="hljs-params">(vec)</span>:</span>
        i = random.randint(<span class="hljs-number">0</span>, len(domain)-<span class="hljs-number">1</span>)
        <span class="hljs-keyword">if</span> random.random() &lt; <span class="hljs-number">0.5</span> <span class="hljs-keyword">and</span> vec[i] &gt; domain[i][<span class="hljs-number">0</span>]:
            <span class="hljs-keyword">return</span> vec[<span class="hljs-number">0</span>:i]+[vec[i]-step]+vec[i+<span class="hljs-number">1</span>:]
        <span class="hljs-keyword">elif</span> vec[i] &lt; domain[i][<span class="hljs-number">1</span>]:
            <span class="hljs-keyword">return</span> vec[<span class="hljs-number">0</span>:i]+[vec[i]+step]+vec[i+<span class="hljs-number">1</span>:]

    <span class="hljs-comment"># 交叉(crossover)操作</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crossover</span><span class="hljs-params">(r1, r2)</span>:</span>
        i = random.randint(<span class="hljs-number">1</span>, len(domain)-<span class="hljs-number">2</span>)
        <span class="hljs-keyword">return</span> r1[<span class="hljs-number">0</span>:i]+r2[i:]

    <span class="hljs-comment"># 构造初始种群</span>
    pop = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(popsize):
        vec = [random.randint(domain[i][<span class="hljs-number">0</span>], domain[i][<span class="hljs-number">1</span>])
                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(domain))]
        pop.append(vec)

    <span class="hljs-comment"># 每一代中有多少胜出者？</span>
    topelite = int(elite * popsize)

    <span class="hljs-comment"># 主循环</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(maxiter):
        scores = [(costf(v), v) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> pop]
        scores.sort()
        ranked = [v <span class="hljs-keyword">for</span> (s,v) <span class="hljs-keyword">in</span> scores]

        <span class="hljs-comment"># 从纯粹的胜出者开始</span>
        pop = ranked[<span class="hljs-number">0</span>:topelite]
        <span class="hljs-comment"># 添加变异和配对后的胜出者</span>
        <span class="hljs-keyword">while</span> len(pop) &lt; popsize:
            <span class="hljs-keyword">if</span> random.random() &lt; mutprob:
                <span class="hljs-comment"># 变异</span>
                c = random.randint(<span class="hljs-number">0</span>, topelite)
                pop.append(mutate(ranked[c]))
            <span class="hljs-keyword">else</span>:
                <span class="hljs-comment"># 交叉</span>
                c1 = random.randint(<span class="hljs-number">0</span>, topelite)
                c2 = random.randint(<span class="hljs-number">0</span>, topelite)
                pop.append(crossover(ranked[c1], ranked[c2]))
        <span class="hljs-comment"># 打印当前最优值</span>
        <span class="hljs-keyword">print</span> scores[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]

    <span class="hljs-keyword">return</span> scores[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]
</code></pre>
<pre><code class="lang-python"><span class="hljs-keyword">print</span> <span class="hljs-string">'遗传算法'</span>
s = geneticoptimize(domain, schedulecost)
printschedule(s)
</code></pre>
<p>优化可能不起作用：一种优化方法是否管用很大程度上取决与问题本身。大多数优化算法都有赖于这样一个事实：对于大多数问题而言，最优解应该接近于其他的优解。
如果成本的最低点实际上处在一个非常陡峭的区域。接近它的任何解都有可能被排除在外，因为这些解的成本都很高，所以我们永远都找不到通往全局最小值的途径。大多数算法都会陷入图中左边某个局部最小化的区域里。</p>
<h3 id="----real-flight-searches">真实的航班搜索 -- Real Flight Searches</h3>
<h4 id="the-kayak-api">The Kayak API</h4>
<h4 id="the-minidom-package">The minidom Package</h4>
<h4 id="----flight-searches">航班搜索 -- Flight Searches</h4>
<h3 id="----optimizing-for-preferences">涉及偏好的优化 -- Optimizing for Preferences</h3>
<p>本节我们考查另一个不同的问题：如何将有限的资源分配给多个表达了偏好的人，并尽可能使他们都满意或尽可能满意</p>
<h4 id="----student-dorm-optimization">学生宿舍优化问题 -- Student Dorm Optimization</h4>
<p>问题：依据学生的首选和次选，为其分配宿舍。
可以推广到：
在线纸牌游戏中玩家的牌桌分配
大型编程项目中开发人员的bug分配
家庭成员中的家务分配</p>
<pre><code class="lang-python"><span class="hljs-comment"># dorm.py</span>
<span class="hljs-keyword">import</span> random
<span class="hljs-keyword">import</span> math

<span class="hljs-comment"># 代表宿舍，每个宿舍有两个可用的隔间</span>
dorms = [<span class="hljs-string">'Zeus'</span>, <span class="hljs-string">'Athena'</span>, <span class="hljs-string">'Hercules'</span>, <span class="hljs-string">'Bacchus'</span>, <span class="hljs-string">'Pluto'</span>]
<span class="hljs-comment"># 代表学生及其首选和次选</span>
prefs = [
    (<span class="hljs-string">'Toby'</span>, (<span class="hljs-string">'Bacchus'</span>, <span class="hljs-string">'Hercules'</span>)),
    (<span class="hljs-string">'Steve'</span>, (<span class="hljs-string">'Zeus'</span>, <span class="hljs-string">'Pluto'</span>)),
    (<span class="hljs-string">'Audrea'</span>, (<span class="hljs-string">'Athena'</span>, <span class="hljs-string">'Zeus'</span>)),
    (<span class="hljs-string">'Sarah'</span>, (<span class="hljs-string">'Zeus'</span>, <span class="hljs-string">'Pluto'</span>)),
    (<span class="hljs-string">'Dave'</span>, (<span class="hljs-string">'Athena'</span>, <span class="hljs-string">'Bacchus'</span>)),
    (<span class="hljs-string">'Jeff'</span>, (<span class="hljs-string">'Hercules'</span>, <span class="hljs-string">'Pluto'</span>)),
    (<span class="hljs-string">'Fred'</span>, (<span class="hljs-string">'Pluto'</span>, <span class="hljs-string">'Athena'</span>)),
    (<span class="hljs-string">'Suzie'</span>, (<span class="hljs-string">'Bacchus'</span>, <span class="hljs-string">'Hercules'</span>)),
    (<span class="hljs-string">'Laura'</span>, (<span class="hljs-string">'Bacchus'</span>, <span class="hljs-string">'Hercules'</span>)),
    (<span class="hljs-string">'Neil'</span>, (<span class="hljs-string">'Hercules'</span>, <span class="hljs-string">'Athena'</span>)),
]

<span class="hljs-comment"># [(0,9), (0,8), (0,7), (0,6),...,(0,0)]</span>
domain = [(<span class="hljs-number">0</span>, (len(dorms)*<span class="hljs-number">2</span>)-i-<span class="hljs-number">1</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(dorms)*<span class="hljs-number">2</span>)]

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printsolution</span><span class="hljs-params">(vec)</span>:</span>
    slots = []
    <span class="hljs-comment"># 为每个宿舍建两个槽</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(dorms)): slots += [i,i]

    <span class="hljs-comment"># 遍历每一名学生的安置情况</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(vec)):
        x = int(vec[i])

        <span class="hljs-comment"># 从剩余槽中选择</span>
        dorm = dorms[slots[x]]
        <span class="hljs-comment"># 输出学生及其被分配的宿舍</span>
        <span class="hljs-keyword">print</span> prefs[i][<span class="hljs-number">0</span>], dorm
        <span class="hljs-comment"># 删除该槽</span>
        <span class="hljs-keyword">del</span> slots[x]
</code></pre>
<h4 id="----the-cost-function">成本函数 -- The Cost Function</h4>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dormcost</span><span class="hljs-params">(vec)</span>:</span>
    cost = <span class="hljs-number">0</span>
    <span class="hljs-comment"># 建立一个槽序列</span>
    slots = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>]
    <span class="hljs-comment"># 遍历每一名学生</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(vec)):
        x = int(vec[i])
        dorm = dorms[slots[x]]
        pref = prefs[i][<span class="hljs-number">1</span>]
        <span class="hljs-comment"># 首选成本为0，次选成本为1</span>
        <span class="hljs-keyword">if</span> pref[<span class="hljs-number">0</span>] == dorm: cost += <span class="hljs-number">0</span>
        <span class="hljs-keyword">elif</span> pref[<span class="hljs-number">1</span>] == dorm: cost += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>: cost += <span class="hljs-number">3</span>
        <span class="hljs-comment"># 不在选择之列则成本值为3</span>

        <span class="hljs-comment"># 删除选中的槽</span>
        <span class="hljs-keyword">del</span> slots[x]

    <span class="hljs-keyword">return</span> cost
</code></pre>
<p>我们知道最优解的成本为零，当优化算法找到一个最优解时，我们可以让优化算法停止搜索更优的解，也可以了解目前与最优解的差距有多少。</p>
<h4 id="----running-the-optimization">执行优化函数 -- Running the Optimization</h4>
<pre><code class="lang-python"><span class="hljs-keyword">print</span> <span class="hljs-string">'分配宿舍'</span>
s = randomoptimize(domain, dormcost)
<span class="hljs-keyword">print</span> dormcost(s)
geneticoptimize(domain, dormcost)
printsolution(s)
</code></pre>
<h3 id="----network-visualization">网络可视化 -- Network Visualization</h3>
<h4 id="----the-layout-problem">布局问题 -- The Layout Problem</h4>
<p>运用优化算法来构建更好的而非杂乱无章的网络图。</p>
<pre><code class="lang-python"><span class="hljs-comment"># socialnetwork.py</span>
<span class="hljs-keyword">import</span> math
people = [<span class="hljs-string">'Charlie'</span>,<span class="hljs-string">'Augustus'</span>,<span class="hljs-string">'Veruca'</span>,<span class="hljs-string">'Violet'</span>,<span class="hljs-string">'Mike'</span>,<span class="hljs-string">'Joe'</span>,<span class="hljs-string">'Willy'</span>,<span class="hljs-string">'Miranda'</span>]
links = [
    (<span class="hljs-string">'Augustus'</span>, <span class="hljs-string">'Willy'</span>),
    (<span class="hljs-string">'Mike'</span>, <span class="hljs-string">'Joe'</span>),
    (<span class="hljs-string">'Miranda'</span>, <span class="hljs-string">'Mike'</span>),
    (<span class="hljs-string">'Violet'</span>, <span class="hljs-string">'Augustus'</span>),
    (<span class="hljs-string">'Miranda'</span>, <span class="hljs-string">'Willy'</span>),
    (<span class="hljs-string">'Charlie'</span>, <span class="hljs-string">'Mike'</span>),
    (<span class="hljs-string">'Veruca'</span>, <span class="hljs-string">'Joe'</span>),
    (<span class="hljs-string">'Miranda'</span>, <span class="hljs-string">'Augustus'</span>),
    (<span class="hljs-string">'Willy'</span>, <span class="hljs-string">'Augustus'</span>),
    (<span class="hljs-string">'Joe'</span>, <span class="hljs-string">'Charlie'</span>),
    (<span class="hljs-string">'Veruca'</span>, <span class="hljs-string">'Augustus'</span>),
    (<span class="hljs-string">'Miranda'</span>, <span class="hljs-string">'Joe'</span>),
]
</code></pre>
<p><strong>质点弹簧算法</strong>（mass-and-sprint algorithm）：从物理学建模而来，各结点彼此向对方施以推力并试图分离，而结点间的连接则试图将关联结点彼此拉近。
借助质点弹簧算法网络便会逐渐呈现出这样一个布局：未关联的节点被推离，而关联的节点则被彼此拉近--却又不会靠得很拢。但该算法无法避免交叉线。</p>
<p>使用优化算法来构建布局：我们只需确定一个成本函数，并尝试令它返回值尽可能地小。在本例中一个值得一试的成本函数是计算彼此交叉的连线数。</p>
<h4 id="----counting-crossed-lines">计算交叉线 -- Counting Crossed Lines</h4>
<p>判断两条线段是否相交：计算线条的&#39;分数值&#39;。如果两条线的分数值介于0（表示线的一端）和1（表示线的另一端）之间，则它们彼此交叉。反之，则不交叉。</p>
<pre><code class="lang-python"><span class="hljs-comment"># socialnetwork.py</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crosscount</span><span class="hljs-params">(v)</span>:</span>
    <span class="hljs-string">'''该函数遍历每一对连线，并利用连线端点的当前坐标来判断它们是否交叉。如果交叉，则总分加1。
    '''</span>
    <span class="hljs-comment"># 将数字序列转换成一个person:(x,y)的字典</span>
    loc = {people[i]:(v[i*<span class="hljs-number">2</span>], v[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, len(people))}
    total = <span class="hljs-number">0</span>
    <span class="hljs-comment"># 遍历每一对连线</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(links)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(links)):
            <span class="hljs-comment"># 获取坐标位置</span>
            (x1,y1), (x2,y2) = loc[links[i][<span class="hljs-number">0</span>]], loc[links[i][<span class="hljs-number">1</span>]]
            (x3,y3), (x4,y4) = loc[links[j][<span class="hljs-number">0</span>]], loc[links[j][<span class="hljs-number">1</span>]]

            den = (y4-y3) * (x2-x1) - (x4-x3)*(y2-y1)

            <span class="hljs-comment"># 如果两线平行，则den==0</span>
            <span class="hljs-keyword">if</span> den==<span class="hljs-number">0</span>: <span class="hljs-keyword">continue</span>

            <span class="hljs-comment"># 否则，ua与ub就是两条交叉线的分数值</span>
            ua = ((x4-x3)*(y1-y3)-(y4-y3)*(x1-x3))/den
            ub = ((x2-x1)*(y1-y3)-(y2-y1)*(x1-x3))/den
            <span class="hljs-comment"># 如果两条线的分数值介于0和1之间，则两线彼此交叉</span>
            <span class="hljs-keyword">if</span> ua&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ua&lt;<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> ub&gt;<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> ub&lt;<span class="hljs-number">1</span>:
                total += <span class="hljs-number">1</span>

    <span class="hljs-comment"># 对两个结点放置太近的题解进行'判罚'(penalize)</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(people)):
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(people)):
            <span class="hljs-comment"># 获取两结点的位置</span>
            (x1,y1),(x2,y2) = loc[people[i]], loc[people[j]]
            <span class="hljs-comment"># 计算两结点的间距</span>
            dist = math.sqrt(math.pow(x1-x2,<span class="hljs-number">2</span>)+math.pow(y1-y2,<span class="hljs-number">2</span>))
            <span class="hljs-comment"># 对间距小于50个像素的结点进行判罚</span>
            <span class="hljs-keyword">if</span> dist &lt; <span class="hljs-number">50</span>:
                total += (<span class="hljs-number">1.0</span> - (dist/<span class="hljs-number">50.0</span>))

    <span class="hljs-keyword">return</span> total

<span class="hljs-comment">#print 'socialnetwork'</span>
<span class="hljs-comment">#sol = randomoptimize(domain, crosscount)</span>
<span class="hljs-comment">#print crosscount(sol)</span>
<span class="hljs-comment">#annealingoptimize(domain, crosscount, step=50, cool=0.99)</span>
<span class="hljs-comment">#print crosscount(sol)</span>
<span class="hljs-comment">#print sol</span>
</code></pre>
<h4 id="----drawing-the-network">绘制网络 -- Drawing the Network</h4>
<pre><code class="lang-python"><span class="hljs-keyword">import</span> Image
<span class="hljs-keyword">import</span> ImageDraw

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawnetwork</span><span class="hljs-params">(sol)</span>:</span>
    <span class="hljs-comment"># 建立image对象</span>
    img = Image.new(<span class="hljs-string">'RGB'</span>,(<span class="hljs-number">400</span>,<span class="hljs-number">400</span>),(<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))
    draw = ImageDraw.Draw(img)
    <span class="hljs-comment"># 建立标示位置信息的字典</span>
    pos = {people[i]:(sol[i*<span class="hljs-number">2</span>],sol[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>,len(people))}
    <span class="hljs-comment"># 绘制连线</span>
    <span class="hljs-keyword">for</span> (a,b) <span class="hljs-keyword">in</span> links:
        draw.line((pos[a], pos[b]), fill=(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
    <span class="hljs-comment"># 绘制代表人的结点</span>
    <span class="hljs-keyword">for</span> n,p <span class="hljs-keyword">in</span> pos.items():
        draw.text(p, n, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))

    img.show()
</code></pre>
<h3 id="----other-possiblities">其他可能的应用场合 -- Other Possiblities</h3>
<h3 id="exercises">Exercises</h3>
<ol>
<li><strong>组团旅游的成本函数</strong>：请以飞机上每分钟0.50美元的成本将总飞行时间计入成本。然后在尝试追加20美元的罚款，以确保任何人都能在上午8点之前抵达机场。</li>
<li><strong>退火算法的初始值</strong>：模拟退火算法的结果很大程度上取决于其初始值。请构造一个优化函数，用多个初始值来模拟退火，并返回最优解。</li>
<li><strong>遗传优化算法的结束条件</strong>：本章中的函数是以固定迭代次数来进行遗传优化的。请改变算法的结束条件，使其在经过10次迭代之后，任一最优解都没有任何改善时，方才结束。</li>
<li><strong>往返定价</strong>：Kayak购买往返机票的价格可能会更加便宜。修改代码取得往返票价，并修改成本函数，令其针对某一特定往返航班进行票价查询，而不是只对单程票价进行求和运算</li>
<li><strong>学生组队</strong>：假设并非要求学生列出对宿舍的偏好，而是令其表达对同住舍友的偏好。那么你将如何表达学生组队的结果呢？成本函数又将如何定义呢？</li>
<li><strong>连线夹角的判断</strong>：请在连接同一个人的两线夹角非常小的时候，为网络布局算法的成本函数在增加一项成本。（提示：可以使用向量的叉乘）</li>
</ol>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../../PCI/cap4/cap4.html" class="navigation navigation-prev " aria-label="Previous page: 搜索与排名"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../../PCI/cap6/cap6.html" class="navigation navigation-next " aria-label="Next page: 文档过滤"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
