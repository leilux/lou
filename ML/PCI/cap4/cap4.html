<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>搜索与排名 | 机器学习</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.1.0">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../../PCI/cap5/cap5.html" />
    
    
    <link rel="prev" href="../../PCI/cap3/cap3.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../../gitbook/style.css">


        
    <div class="book" data-level="1.3" data-basepath="../.." data-revision="1428042646490">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="PCI/readme.html">
            
                
                    <a href="../../PCI/readme.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         集体智慧编程
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="PCI/cap2/cap2.html">
            
                
                    <a href="../../PCI/cap2/cap2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         提供推荐
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.2" data-path="PCI/cap3/cap3.html">
            
                
                    <a href="../../PCI/cap3/cap3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         发现群组
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="1.3" data-path="PCI/cap4/cap4.html">
            
                
                    <a href="../../PCI/cap4/cap4.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.3.</b>
                        
                         搜索与排名
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.4" data-path="PCI/cap5/cap5.html">
            
                
                    <a href="../../PCI/cap5/cap5.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.4.</b>
                        
                         优化
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.5" data-path="PCI/cap6/cap6.html">
            
                
                    <a href="../../PCI/cap6/cap6.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.5.</b>
                        
                         文档过滤
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.6" data-path="PCI/cap7/cap7.html">
            
                
                    <a href="../../PCI/cap7/cap7.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.6.</b>
                        
                         决策树建模
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.7" data-path="PCI/cap8/cap8.html">
            
                
                    <a href="../../PCI/cap8/cap8.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.7.</b>
                        
                         构建价格模型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.8" data-path="PCI/cap9/cap9.html">
            
                
                    <a href="../../PCI/cap9/cap9.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.8.</b>
                        
                         高阶分类：核心方法和SVMs
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.9" data-path="PCI/cap10/cap10.html">
            
                
                    <a href="../../PCI/cap10/cap10.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.9.</b>
                        
                         寻找独立特征
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.10" data-path="PCI/cap11/cap11.html">
            
                
                    <a href="../../PCI/cap11/cap11.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.10.</b>
                        
                         智能进化
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.11" data-path="PCI/cap12/cap12.html">
            
                
                    <a href="../../PCI/cap12/cap12.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.11.</b>
                        
                         算法总结
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../" >机器学习</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_1">
                    
                        <h2 id="----searching-and-ranking">搜索与排名 -- Searching and Ranking</h2>
<p>对信息检索（information retrieval）中一部分关键概念加以解释
完整地介绍一个搜索引擎的构造过程。
检索网页（crawl）、建立索引、对网页进行搜索，以及以多种不同方式对搜索的结果进行排名</p>
<h3 id="----whats-in-a-search-engine">搜索引擎的组成 -- what&#39;s in a search engine?</h3>
<pre><code class="lang-python"><span class="hljs-comment">#searchengine.py</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">carwler</span>:</span>
    <span class="hljs-comment"># 初始化crawler类并传入数据库名称</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, dbname)</span>:</span>
        self.con = sqlite.connect(dbname)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span>
        self.con.close()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbcommit</span><span class="hljs-params">(self)</span>:</span>
        self.con.commit()

    <span class="hljs-comment"># 辅助函数，用于获取条目的id，并且如果条目不存在，就将其加入数据库中</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getentryid</span><span class="hljs-params">(self, table, filed, value, createnew=True)</span>:</span>
        cur = self.execute(
            <span class="hljs-string">"select rowid from %s where %s='%s'"</span> % (table, field, value))
        res = cur.fetchone()
        <span class="hljs-keyword">if</span> res == <span class="hljs-keyword">None</span>:
            cur = self.con.execute(
                <span class="hljs-string">"insert into %s (%s) values ('%s')"</span> % (table, field, value))
            <span class="hljs-keyword">return</span> cur.lastrowid
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]

    <span class="hljs-comment"># 为每个网页建立索引</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addtoindex</span><span class="hljs-params">(self, url, soup)</span>:</span>
        <span class="hljs-keyword">if</span> self.isindexed(url): <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">print</span> <span class="hljs-string">'Indexing '</span> + url
        <span class="hljs-comment"># 获取每个单词</span>
        text = self.gettextonly(soup)
        words = self.separatewords(text)

        <span class="hljs-comment"># 得到URL的id</span>
        urlid = self.getentryid(<span class="hljs-string">'urllist'</span>, <span class="hljs-string">'url'</span>, url)

        <span class="hljs-comment"># 将每个单词与该url关联</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(words)):
            word = words[i]
            <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> ignorewords: <span class="hljs-keyword">continue</span>
            wordid = self.getentryid(<span class="hljs-string">'wordlist'</span>, <span class="hljs-string">'word'</span>, word)
            self.con.execute(<span class="hljs-string">'insert into wordlocation(urlid,wordid,location) values (%d,%d,%d)'</span> %(urlid, wordid,i)


    <span class="hljs-comment"># 从一个HTML网页中提取文字（不带标签的）</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gettextonly</span><span class="hljs-params">(self, soup)</span>:</span>
        v = soup.string
        <span class="hljs-keyword">if</span> v == <span class="hljs-keyword">None</span>:
            c = soup.contents
            resulttext = <span class="hljs-string">''</span>
            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> c:
                subtext = self.gettextonly(t)
                resulttext += subtext + <span class="hljs-string">'\n'</span>
            <span class="hljs-keyword">return</span> resulttext
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> v.strip()

    <span class="hljs-comment"># 根据任何非空白字符进行分词处理</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">separatewords</span><span class="hljs-params">(self, text)</span>:</span>
        splitter = re.compile(<span class="hljs-string">'\\W*'</span>)
        <span class="hljs-keyword">return</span> [s.lower() <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> splitter.split(text) <span class="hljs-keyword">if</span> s!=<span class="hljs-string">''</span>]

    <span class="hljs-comment"># 如果url已经建过索引，则返回true</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isindexed</span><span class="hljs-params">(self, url)</span>:</span>
        u = self.con.execute(
            <span class="hljs-string">"select rowid from urllist where url='%s'"</span> % url).fetchone()
        <span class="hljs-keyword">if</span> u!=<span class="hljs-keyword">None</span>:
            <span class="hljs-comment"># 检查它是否已经被检索过了</span>
            v = self.con.execute(
                <span class="hljs-string">'select * from wordlocation where urlid=%d'</span> % u[<span class="hljs-number">0</span>]).fetchone()
            <span class="hljs-keyword">if</span> v != <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">True</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">False</span>


    <span class="hljs-comment"># 添加一个关联两个网页的链接</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addlinkref</span><span class="hljs-params">(self, urlFrom, urlTo, linkText)</span>:</span>
        words = self.separateWords(linkText)
        fromid = self.getentryid(<span class="hljs-string">'urllist'</span>,<span class="hljs-string">'url'</span>,urlFrom)
        toid = self.getentryid(<span class="hljs-string">'urllist'</span>,<span class="hljs-string">'url'</span>,urlTo)
        <span class="hljs-keyword">if</span> fromid == toid: <span class="hljs-keyword">return</span>
        cur = self.con.execute(<span class="hljs-string">"insert into link(fromid,toid) values (%d,%d)"</span> % (fromid,toid))
        linkid = cur.lastrowid
        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:
            <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> ignorewords: <span class="hljs-keyword">continue</span>
            wordid = self.getentryid(<span class="hljs-string">'wordlist'</span>,<span class="hljs-string">'word'</span>,word)
            self.con.execute(<span class="hljs-string">"insert into linkwords(linkid,wordid) values (%d,%d)"</span> % (linkid,wordid))


    <span class="hljs-comment"># 从一小组网页开始进行广度优先搜索，直至某一给定深度，</span>
    <span class="hljs-comment"># 期间为网页建立索引</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl</span><span class="hljs-params">(self, pages, depth=<span class="hljs-number">2</span>)</span>:</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(depth):
            newpages = set()
            <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> pages:
                <span class="hljs-keyword">try</span>:
                    c = urllib2.urlopen(page)
                <span class="hljs-keyword">except</span>:
                    <span class="hljs-keyword">print</span> <span class="hljs-string">'could not open %s'</span>%page
                    <span class="hljs-keyword">continue</span>
                soup = BeautifulSoup(c.read())
                self.addtoindex(page, soup)

                links = soup(<span class="hljs-string">'a'</span>)
                <span class="hljs-keyword">for</span> link <span class="hljs-keyword">in</span> links:
                    <span class="hljs-keyword">if</span> <span class="hljs-string">'href'</span> <span class="hljs-keyword">in</span> dict(link.attrs):
                        url = urljoin(page, link[<span class="hljs-string">'href'</span>])
                        <span class="hljs-keyword">if</span> url.find(<span class="hljs-string">"'"</span>)!=-<span class="hljs-number">1</span>: <span class="hljs-keyword">continue</span>
                        url = url.split(<span class="hljs-string">'#'</span>)[<span class="hljs-number">0</span>]
                        <span class="hljs-keyword">if</span> url[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] == <span class="hljs-string">'http'</span> <span class="hljs-keyword">and</span> self.isindexed(url):
                            newpages.add(url)
                        linkText = self.gettextonly(link)
                        self.addlinkref(page, url, linkText)
                self.dbcommit()
            pages = newpages

    <span class="hljs-comment"># 创建数据库表</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createindextables</span><span class="hljs-params">(self)</span>:</span>
        self.con.execute(<span class="hljs-string">'create table urllist(url)'</span>)
        self.con.execute(<span class="hljs-string">'create table wordlist(word)'</span>)
        self.con.execute(<span class="hljs-string">'create table wordlocation(urlid,wordid,location'</span>)
        self.con.execute(<span class="hljs-string">'create link(fromid integer,toid integer)'</span>)
        self.con.execute(<span class="hljs-string">'create linkwords(wordid,linkid)'</span>)
        self.con.execute(<span class="hljs-string">'create index wordidx on wordlist(word)'</span>)
        self.con.execute(<span class="hljs-string">'create index urlidx on urllist(url)'</span>)
        self.con.execute(<span class="hljs-string">'create index wordurlidx on wordlocation(wordid)'</span>)
        self.con.execute(<span class="hljs-string">'create index urltoidx on link(toid)'</span>)
        self.con.execute(<span class="hljs-string">'create index urlfromidx on link(fromid)'</span>)

        self.dbcommit()
</code></pre>
<pre><code class="lang-python"><span class="hljs-comment">###一个简单的爬虫程序 -- A Simple Crawler</span>

<span class="hljs-comment"># http://segaran.com/wiki</span>

<span class="hljs-comment">###Using urllib2</span>

<span class="hljs-keyword">import</span> urllib2
<span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup
<span class="hljs-keyword">from</span> urlparse <span class="hljs-keyword">import</span> urljoin

<span class="hljs-comment"># 构造一个单词列表，这些单词将被忽略</span>
ignorewords = set([<span class="hljs-string">'the'</span>,<span class="hljs-string">'of'</span>,<span class="hljs-string">'to'</span>,<span class="hljs-string">'and'</span>,<span class="hljs-string">'a'</span>,<span class="hljs-string">'in'</span>,<span class="hljs-string">'is'</span>,<span class="hljs-string">'it'</span>])

<span class="hljs-comment">###爬虫程序的代码 -- Crawler Code</span>

<span class="hljs-comment"># 广度优先的搜索方式</span>
<span class="hljs-comment"># crawler.crawl(self, pages, depth=2)</span>

<span class="hljs-comment">###建立索引 -- Building the Index</span>

<span class="hljs-keyword">import</span> sqlite3 <span class="hljs-keyword">as</span> sqlite
<span class="hljs-comment"># crawler.__init__(self, dbname)</span>
<span class="hljs-comment"># crawler.__del__(self)</span>
<span class="hljs-comment"># crawler.dbcommit(self)</span>


<span class="hljs-comment">###建立数据库schema -- Setting Up the Schema</span>

<span class="hljs-comment">#     +-------+      +--------+          +---------+</span>
<span class="hljs-comment">#     | link  |      | urllist|          | pagerank|</span>
<span class="hljs-comment">#     |-----  |  +---|----    |--------+ |-------- |</span>
<span class="hljs-comment">#   +-|rowid  |  |+--|rowid   |-----+  +-|urlid    |</span>
<span class="hljs-comment">#   | |fromid |--+|  |url     |     |    |score    |</span>
<span class="hljs-comment">#   | |toid   |---+  +--------+     |    +---------+</span>
<span class="hljs-comment">#   | +-------+                     |  </span>
<span class="hljs-comment">#   |                               |  </span>
<span class="hljs-comment">#   |                               |    +-------------+</span>
<span class="hljs-comment">#   | +----------+     +---------+  |    | wordlocation|</span>
<span class="hljs-comment">#   | | linkwords|     | wordlist|  |    |----------   |</span>
<span class="hljs-comment">#   | |--------  |     |-------  |  +----|urlid        |</span>
<span class="hljs-comment">#   | |wordid    |-----|rowid    |-------|wordid       |</span>
<span class="hljs-comment">#   +-|linkid    |     |word     |       |location     |</span>
<span class="hljs-comment">#     +----------+     +---------+       +-------------+                  </span>

<span class="hljs-comment"># createindextables(self)</span>

<span class="hljs-comment">#print 'setting up the schema'</span>
<span class="hljs-comment">#crawler = crawler('searchindex.db')</span>
<span class="hljs-comment">#crawler.createindextables()</span>


<span class="hljs-comment">###在网页中查找单词 -- Finding the Words on a page</span>

<span class="hljs-comment"># crawler.gettextonly(self, soup)</span>
<span class="hljs-comment"># crawler.separatewords(self, text)</span>
<span class="hljs-comment"># 中文分词：jieba</span>
<span class="hljs-comment"># 词干提取算法（stemming algorithm） </span>
<span class="hljs-comment">#    http://www.tartarus.org/~martin/PorterStemmer/index.html</span>
<span class="hljs-comment">#    Porter Stemmer</span>

<span class="hljs-comment">###加入索引 -- Adding to the Index</span>

<span class="hljs-comment"># crawler.addtoindex(self, url, soup)</span>
<span class="hljs-comment"># crawler.getentryid(self, table, field, value,createnew=True)</span>
<span class="hljs-comment"># crawler.isindexed(self, url)</span>


<span class="hljs-comment">#print 'adding to the index'</span>
<span class="hljs-comment">#crawler = crawler('searchindex.db')</span>
<span class="hljs-comment">#pages = ['http://segaran.com/wiki/Categorical_list_of_programming_languages.html']</span>
<span class="hljs-comment">#crawler.crawl(pages)</span>

<span class="hljs-comment"># 也可以从 http://segaran.com/db/searchindex.db下载 searchindex.db</span>
</code></pre>
<h3 id="----querying">查询 -- Querying</h3>
<pre><code class="lang-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">searcher</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, dbname)</span>:</span>
        self.mynet = searchnet(<span class="hljs-string">'nn.db'</span>)
        self.con = sqlite.connect(dbname)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span>
        self.con.close()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getmatchrows</span><span class="hljs-params">(self, q)</span>:</span>
        <span class="hljs-string">'''接受一个查询字符串作为参数，并将其拆分为多个单词，然后构造一个SQL查询，只查找那些包含所有不同单词的URL
        example:
          select w0.urlid, w0.location, w1.location
          from wordlocation w0, wordlocation w1
          where w0.urlid=w1.urlid
          and w0.wordid=10
          and w1.wordid=17
        '''</span>
        <span class="hljs-comment"># 构造查询的字符串</span>
        fieldlist = <span class="hljs-string">'w0.urlid'</span>
        tablelist = <span class="hljs-string">''</span>
        clauselist = <span class="hljs-string">''</span>
        wordids = []

        <span class="hljs-comment"># 根据空格拆分单词</span>
        words = q.split(<span class="hljs-string">' '</span>)
        tablenumber = <span class="hljs-number">0</span>

        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:
            <span class="hljs-comment"># 获取单词的ID</span>
            wordrow = self.con.execute(
                <span class="hljs-string">"select rowid from wordlist where word='%s'"</span> % word).fetchone()
            <span class="hljs-keyword">if</span> wordrow != <span class="hljs-keyword">None</span>:
                wordid = wordrow[<span class="hljs-number">0</span>]
                wordids.append(wordid)
                <span class="hljs-keyword">if</span> tablenumber &gt; <span class="hljs-number">0</span>:
                    tablelist += <span class="hljs-string">','</span>
                    clauselist += <span class="hljs-string">' and '</span>
                    clauselist += <span class="hljs-string">'w%d.urlid=w%d.urlid and '</span> % (tablenumber-<span class="hljs-number">1</span>, tablenumber)
                fieldlist += <span class="hljs-string">',w%d.location'</span> % tablenumber
                tablelist += <span class="hljs-string">'wordlocation w%d'</span> % tablenumber
                clauselist += <span class="hljs-string">'w%d.wordid=%d'</span> % (tablenumber, wordid)
                tablenumber += <span class="hljs-number">1</span>

        <span class="hljs-comment"># 根据各个组分，建立查询</span>
        fullquery = <span class="hljs-string">'select %s from %s where %s'</span> % (fieldlist, tablelist, clauselist)
        cur = self.con.execute(fullquery)
        rows = [row <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur]
        <span class="hljs-comment"># rows[w0.urlid w0.location w1.location]</span>
        <span class="hljs-keyword">return</span> rows, wordids

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getscoredlist</span><span class="hljs-params">(self, rows, wordids)</span>:</span>
        totalscores = {row[<span class="hljs-number">0</span>]:<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}

        <span class="hljs-comment"># 此处是稍后放置评价函数的地方</span>
        weights = [
            (<span class="hljs-number">1.0</span>, self.frequencyscore(rows)),
            (<span class="hljs-number">1.0</span>, self.locationscore(rows)),
            (<span class="hljs-number">1.0</span>, self.distancescore(rows)),
            (<span class="hljs-number">1.0</span>, self.pagerankscore(rows)),
            (<span class="hljs-number">1.0</span>, self.linktextscore(rows, wordids)),
            (<span class="hljs-number">1.0</span>, self.nnscore(rows, wordids)),
        ]

        <span class="hljs-keyword">for</span> (weight, scores) <span class="hljs-keyword">in</span> weights:
            <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> totalscores:
                totalscores[url] += weight*scores[url]

        <span class="hljs-keyword">return</span> totalscores

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">geturlname</span><span class="hljs-params">(self, id)</span>:</span>
        <span class="hljs-keyword">return</span> self.con.execute(
            <span class="hljs-string">"select url from urllist where rowid=%d"</span> % id).fetchone()[<span class="hljs-number">0</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">query</span><span class="hljs-params">(self, q)</span>:</span>
        <span class="hljs-string">'''查询结果'''</span>
        rows, wordids = self.getmatchrows(q)
        scores = self.getscoredlist(rows, wordids)
        rankedscores = sorted([(score, url) <span class="hljs-keyword">for</span> (url, score) <span class="hljs-keyword">in</span> scores.items()], reverse=<span class="hljs-keyword">True</span>)
        <span class="hljs-keyword">for</span> (score, urlid) <span class="hljs-keyword">in</span> rankedscores[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]:
            <span class="hljs-keyword">print</span> <span class="hljs-string">'%f\t%s'</span> % (score, self.geturlname(urlid))
        <span class="hljs-comment"># 此结果可以被直接传入searchnet.trainquery(wordids, urlids, selectedurl)</span>
        <span class="hljs-keyword">return</span> wordids, [r[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> rankedscores[<span class="hljs-number">0</span>:<span class="hljs-number">10</span>]]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normalizescores</span><span class="hljs-params">(self, scores, smallIsBetter=False)</span>:</span>
        <span class="hljs-string">'''将结果归一化处理，并返回一个介于0和1之间的值'''</span>
        vsmall = <span class="hljs-number">0.00001</span> <span class="hljs-comment"># 避免除零</span>
        <span class="hljs-keyword">if</span> smallIsBetter:
            minscore = min(scores.values())
            <span class="hljs-keyword">return</span> {u: float(minscore)/max(vsmall, i) <span class="hljs-keyword">for</span> (u, i) <span class="hljs-keyword">in</span> scores.items()}
        <span class="hljs-keyword">else</span>:
            maxscore = max(scores.values())
            <span class="hljs-keyword">if</span> maxscore == <span class="hljs-number">0</span>: maxscore = vsmall
            <span class="hljs-keyword">return</span> {u: float(c)/maxscore) <span class="hljs-keyword">for</span> (u,c) <span class="hljs-keyword">in</span> scores.items()}

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">frequencyscore</span><span class="hljs-params">(self, rows)</span>:</span>
        <span class="hljs-string">'''单词频度'''</span>
        counts = {row[<span class="hljs-number">0</span>]: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows: counts[row[<span class="hljs-number">0</span>]] += <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> self.normalizescores(counts)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">locationscore</span><span class="hljs-params">(self, rows)</span>:</span>
        <span class="hljs-string">'''文档位置'''</span>
        locations = {row[<span class="hljs-number">0</span>]: <span class="hljs-number">1000000</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}
        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:
            loc = sum(row[<span class="hljs-number">1</span>:])
            <span class="hljs-keyword">if</span> loc &lt; locations[row[<span class="hljs-number">0</span>]]: locations[row[<span class="hljs-number">0</span>]] = loc
        <span class="hljs-keyword">return</span> self.normalizescores(locations, smallIsBetter=<span class="hljs-keyword">True</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distancescore</span><span class="hljs-params">(self, rows)</span>:</span>
        <span class="hljs-string">'''单词距离'''</span>
        <span class="hljs-comment"># 如果仅有一个单词，则得分都一样</span>
        <span class="hljs-keyword">if</span> len(rows[<span class="hljs-number">0</span>]) &lt;= <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> {row[<span class="hljs-number">0</span>]: <span class="hljs-number">1.0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}

        <span class="hljs-comment"># 初始化字典，并填入一个很大的数</span>
        mindistance = {row[<span class="hljs-number">0</span>]: <span class="hljs-number">1000000</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}

        <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows:
            dist = sum(abs(row[i]-row[i-<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, len(row)))
            <span class="hljs-keyword">if</span> dist &lt; mindistance[row[<span class="hljs-number">0</span>]]: mindistance[row[<span class="hljs-number">0</span>]] = dist
        <span class="hljs-keyword">return</span> self.normalizescores(mindistance, smallIsBetter=<span class="hljs-keyword">True</span>)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inboundlinkscore</span><span class="hljs-params">(self, rows)</span>:</span>
        <span class="hljs-string">'''inbound link 简单计数'''</span>
        uniqueurls = set([row[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows])
        inboundcount = {u: self.con.execute(
            <span class="hljs-string">'select count(*) from link where toid=%d'</span> % u).fetchone()[<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> u <span class="hljs-keyword">in</span> uniqueurls}
        <span class="hljs-keyword">return</span> self.normalizescores(inboundcount)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculatepagerank</span><span class="hljs-params">(self, iterations=<span class="hljs-number">20</span>)</span>:</span>
        <span class="hljs-comment"># 清除当前的PageRank表</span>
        self.con.execute(<span class="hljs-string">'drop table if exists pagerank'</span>)
        self.con.execute(<span class="hljs-string">'create table pagerank(urlid primary key, score)'</span>)

        <span class="hljs-comment"># 初始化每个url，令其PageRank值为1</span>
        self.con.execute(<span class="hljs-string">'insert into pagerank select rowid, 1.0 from urllist'</span>)
        self.dbcommit()

        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(iterations):
            <span class="hljs-keyword">print</span> <span class="hljs-string">'Iteration %d'</span> % i
            <span class="hljs-keyword">for</span> (urlid,) <span class="hljs-keyword">in</span> self.con.execute(<span class="hljs-string">'select rowid from urllist'</span>):
                pr = <span class="hljs-number">0.15</span>
                <span class="hljs-comment"># 循环遍历指向当前网页的所有其他网页</span>
                <span class="hljs-keyword">for</span> (linker,) <span class="hljs-keyword">in</span> self.con.execute(
                    <span class="hljs-string">'select distinct fromid from link where toid=%d'</span> % urlid):
                    <span class="hljs-comment"># 得到链接源对应网页的PageRank值</span>
                    linkingpr = self.con.execute(
                        <span class="hljs-string">'select score from pagerank where urlid=%d'</span> % linker).fetchone()[<span class="hljs-number">0</span>]

                    <span class="hljs-comment"># 根据链接源，求得总的链接数</span>
                    linkingcount = self.con.execute(
                        <span class="hljs-string">'select count(*) from link where fromid=%d'</span> % linker).fetchone()[<span class="hljs-number">0</span>]
                    pr += <span class="hljs-number">0.85</span>*(linkingpr/linkingcount)
                self.con.execute(
                    <span class="hljs-string">'update pagerank set score=%f where urlid=%d'</span> % (pr, urlid))
            self.dbcommit()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pagerankscore</span><span class="hljs-params">(self, rows)</span>:</span>
        <span class="hljs-string">'''PageRank'''</span>
        pageranks = {row[<span class="hljs-number">0</span>]: self.con.execute(<span class="hljs-string">'select score from pagerank where urlid=%d'</span> % row[<span class="hljs-number">0</span>]).fetchone()[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}
        maxrank = max(pageranks.values())
        normalizescores = {u: float(l)/maxrank <span class="hljs-keyword">for</span> (u,l) <span class="hljs-keyword">in</span> pageranks.items()}
        <span class="hljs-keyword">return</span> normalizescores

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">linktextscore</span><span class="hljs-params">(self, rows, wordids)</span>:</span>
        <span class="hljs-string">'''链接文本 + pagerank'''</span>
        linkscores = {row[<span class="hljs-number">0</span>]: <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows}
        <span class="hljs-keyword">for</span> wordid <span class="hljs-keyword">in</span> wordids:
            cur = self.con.execute(<span class="hljs-string">'select link.fromid, link.toid from linkwords, link where wordid=%d and linkwords.linkid=link.rowid'</span> % wordid)
            <span class="hljs-keyword">for</span> (fromid, toid) <span class="hljs-keyword">in</span> cur:
                <span class="hljs-keyword">if</span> toid <span class="hljs-keyword">in</span> linkscores:
                    pr = self.con.execute(<span class="hljs-string">'select score from pagerank where urlid=%d'</span> % fromid).fetchone()[<span class="hljs-number">0</span>]
                    linkscores[toid] += pr
        maxscore = max(linkscores.values())
        normalizescores = {u:float(l)/maxscore <span class="hljs-keyword">for</span> (u,l) <span class="hljs-keyword">in</span> linkscores.items()}
        <span class="hljs-keyword">return</span> normalizescores

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nnscore</span><span class="hljs-params">(self.rows, wordids)</span>:</span>
        <span class="hljs-comment"># 获取一个由唯一的URL ID构成的有序列表</span>
        urlids = [urlid <span class="hljs-keyword">for</span> urlid <span class="hljs-keyword">in</span> set([row[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows])]
        nnres = self.mynet.getresult(wordids, urlids)
        scores = {urlids[i]: nnres[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(urlids))}
        <span class="hljs-keyword">return</span> self.normalizescores(scores)
</code></pre>
<h3 id="----content-based-ranking">基于内容的排名 -- Content-Based Ranking</h3>
<p>对几种只依据查询条件和网页内容进行评价计算的方法进行考查。包括以下三种：</p>
<ol>
<li>单词频度</li>
<li>文档位置：文档的主题有可能会出现在靠近文档的开始处</li>
<li>单词距离：多个单词在文档中出现的位置应该靠得很近</li>
</ol>
<pre><code class="lang-python">searcher.getscoredlist(self, rows, wordids)
searcher.geturlname(self, id)
searcher.query(self, q)
</code></pre>
<h4 id="----normalization-function">归一化函数 -- Normalization Function</h4>
<p>searcher.normalizescores(self, scores, smallIsBetter=0)</p>
<h4 id="----word-frequency">单词频度 -- Word Frequency</h4>
<p>searcher.frequencyscore(self, rows)</p>
<h4 id="----document-location">文档位置 -- Document Location</h4>
<p>searcher.locationscore(self, rows)</p>
<h4 id="----word-distance">单词距离 -- Word Distance</h4>
<p>searcher.distancescore(self, rows)</p>
<h3 id="----using-inbound-links">利用外部回指链接 -- Using Inbound Links</h3>
<h4 id="----simple-count">简单计数 -- Simple Count</h4>
<p>searcher.inboundlinkscore(self, rows)</p>
<h4 id="pagerank----the-pagerank-algorithm">PageRank算法 -- The PageRank Algorithm</h4>
<p>网页的重要性依据指向该网页的所有其他网页的重要性，以及这些网页中所包含的链接数求得
PageRank计算的是某个人在任意次链接点击之后到达某一网页的可能性。
如果某个网页拥有来自其他热门网页的外部回指链接越多，人们无意间到达该网页的可能性也就越大.
如果用户始终不停地点击，那么他们终将到达每一个网页，但是绝大多数人在浏览一段时间后都会停止点击。
为了反映这一情况，PageRank还使用了一个值为0.85的阻尼因子，用以指示用户持续点击每个网页中链接的概率为85%。</p>
<pre><code>       +---+      +---+      +---+
   &lt;---| B |      | A |      | C |-----&gt;
   &lt;---|   |----&gt; |   | &lt;----|   |-----&gt;
   &lt;---|.5 |      | ? |      |.7 |-----&gt;
       +---+      +---+      +---+
                    ^
                    |
                  +---+
                  | D |
                  |.2 |
                  +---+
 PR(A) = 0.15 + 0.85 * (PR(B)/links(B) + PR(C)/links(C) + PR(D)/links(D))
       = 0.15 + 0.85 * (0.5/4 + 0.7/5 + 0.2/1)
       = 0.15 + 0.85 * (0.125 + 0.14 + 0.2)
       = 0.54525
</code></pre><p>如何对一组还没有PageRank值的网页进行PageRank计算？
解决：为所有的PageRank都设置一个任意的初始值，然后反复计算，迭代若干次。
      每次迭代期间每个网页的PageRank值将会越来越接近真实值</p>
<pre><code>searcher.calculatepagerank(self, iterations=20)
searcher.pagerankscore(self, rows)
</code></pre><h4 id="----using-the-link-text">利用链接文本 -- Using the Link Text</h4>
<p>searcher.linktextscore(slef, rows, wordids)</p>
<h3 id="----learning-from-clicks">从点击行为中学习 -- Learning from Clicks</h3>
<p>记录用户点击查询结果的情况，并利用这一信息来改进搜索结果的排名
构造一个人工神经网络（artificail neural network）
向其提供：提供查询条件中的单词，返回给用户的搜索结果，以及用户的点击决策，然后再对其加以训练。</p>
<h4 id="----design-of-a-click-tracking-network">一个点击跟踪网络的设计 -- Design of a Click-Tracking Network</h4>
<p>神经网络都以一组节点（神经元）构成，并且彼此相连。
将要介绍的为多层感知机（multilayer perceptron，MLP）网络。
此类网络有多层神经元构造而成，
其中第一层神经元接受输入，本例中，即用户输入的单词
最后一层神经元给予输出，本例中，即一个涉及被返回的不同URL的权重列表
神经网络可以有多个中间层，因为外界无法直接与其交互，所以该中间层被称为隐藏层，其职责是对输入进行组合。</p>
<p>本节用一种称为反向传播（backpropagation）的算法对网络进行训练</p>
<p>为什么要用神经网络这样的复杂技术？ 它能根据与其他查询的相似度情况，对以前从未见过的查询结果做出合理的猜测。</p>
<h4 id="----setting-up-the-database">设置数据库 -- Setting Up the Database</h4>
<pre><code>数据表
hiddennode(create_key)：代表隐藏层的数据表
wordhidden(fromid,toid,strength)：单词层到隐藏层的连接状况
hiddenurl(fromid,toid,strength)：隐藏层与输出层连接状况
</code></pre><pre><code class="lang-python"><span class="hljs-comment"># nn.py</span>
<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> tanh
<span class="hljs-keyword">import</span> sqlite3 <span class="hljs-keyword">as</span> sqlite

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">searchnet</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, dbname)</span>:</span>
        self.con = sqlite.connect(dbname)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__del__</span><span class="hljs-params">(self)</span>:</span>
        self.con.close()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maketables</span><span class="hljs-params">(self)</span>:</span>
        self.con.execute(<span class="hljs-string">'create table hiddennode(create_key)'</span>)
        self.con.execute(<span class="hljs-string">'create table wordhidden(fromid,toid,strength)'</span>)
        self.con.execute(<span class="hljs-string">'create table hiddenurl(fromid,toid,strength)'</span>)
        self.con.commit()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getstrength</span><span class="hljs-params">(self, fromid, toid, layer)</span>:</span>
        <span class="hljs-keyword">if</span> layer == <span class="hljs-number">0</span>: talbe = <span class="hljs-string">'wordhidden'</span>
        <span class="hljs-keyword">else</span>: table = <span class="hljs-string">'hiddenurl'</span>
        res = self.con.execute(<span class="hljs-string">'select strength from %s where fromid=%d and toid=%d'</span> % (table, fromid, toid)).fetchone()
        <span class="hljs-keyword">if</span> res == <span class="hljs-keyword">None</span>:
            <span class="hljs-keyword">if</span> layer == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> -<span class="hljs-number">0.2</span>
            <span class="hljs-keyword">if</span> layer == <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> res[<span class="hljs-number">0</span>]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setstrength</span><span class="hljs-params">(self, fromid, toid, layer, strength)</span>:</span>
        <span class="hljs-string">'''判断连接是否已存在，并利用新的强度值更新连接或创建连接'''</span>
        <span class="hljs-keyword">if</span> layer == <span class="hljs-number">0</span>: table = <span class="hljs-string">'wordhidden'</span>
        <span class="hljs-keyword">else</span>: table = <span class="hljs-string">'hiddenurl'</span>
        res = self.con.execute(<span class="hljs-string">'select rowid from %s where fromid=%d and toid=%d'</span> % (table,fromid,toid)).fetchone()
        <span class="hljs-keyword">if</span> res == <span class="hljs-keyword">None</span>:
            self.con.execute(<span class="hljs-string">'insert into %s (fromid, toid, strength) values (%d, %d, %f)'</span> % (table, fromid, toid, strength))
        <span class="hljs-keyword">else</span>:
            rowid = res[<span class="hljs-number">0</span>]
            self.con.execute(<span class="hljs-string">'update %s set strength=%f where rowid=%d'</span> % (table, strength, rowid))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generatehiddennode</span><span class="hljs-params">(self, wordids, urls)</span>:</span>
        <span class="hljs-string">'''每传入一组从前未见过的单词组合，就会在隐藏层建立一个新的节点，
        随后会为单词与隐藏节点之间，及查询节点与url结果之间建立有默认权重的连接
        '''</span>
        <span class="hljs-keyword">if</span> len(wordids) &gt; <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-keyword">None</span>
        <span class="hljs-comment"># 检查我们是否已经为这组单词建好了一个节点</span>
        createkey = <span class="hljs-string">'_'</span>.join(sorted([str(wi) <span class="hljs-keyword">for</span> wi <span class="hljs-keyword">in</span> wordids]))
        res = self.con.execute(
            <span class="hljs-string">"select rowid from hiddennode where create_key='%s'"</span> % createkey).fetchone()

        <span class="hljs-comment"># 如果没有，则建立之</span>
        <span class="hljs-keyword">if</span> res == <span class="hljs-keyword">None</span>:
            cur = self.con.execute(
                <span class="hljs-string">"insert into hiddennode (create_key) values ('%s')"</span> % createkey)
            hiddenid = cur.lastrowid
            <span class="hljs-comment"># 设置默认权重</span>
            <span class="hljs-keyword">for</span> wordid <span class="hljs-keyword">in</span> wordids:
                self.setstrength(wordid, hiddenid, <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>/len(wordids))
            <span class="hljs-keyword">for</span> urlid <span class="hljs-keyword">in</span> urls:
                self.setstrength(hiddenid, urlid, <span class="hljs-number">1</span>, <span class="hljs-number">0.1</span>)
            self.con.commit()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getallhiddenids</span><span class="hljs-params">(self, wordids, urlids)</span>:</span>
        <span class="hljs-string">'''从隐藏层中找出与某项查询相关的所有节点，
        其他节点不会用来判断结果或训练网络，没必要将它们包含在内
        '''</span>
        ll = {}
        <span class="hljs-keyword">for</span> wordid <span class="hljs-keyword">in</span> wordids:
            cur = self.con.execute(
                <span class="hljs-string">'select toid from wordhidden where fromid=%d'</span> % wordid)
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur: ll[row[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">for</span> urlid <span class="hljs-keyword">in</span> urlids:
            cur = self.con.execute(
                <span class="hljs-string">'select fromid from hiddenurl where toid=%d'</span> % urlid)
            <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> cur: ll[row[<span class="hljs-number">0</span>]] = <span class="hljs-number">1</span>
        <span class="hljs-keyword">return</span> ll.keys()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setupnetwork</span><span class="hljs-params">(self, wordids, urlids)</span>:</span>
        <span class="hljs-string">'''利用数据库中保存的信息，建立起包括所有当前权重值在内相应网络
        '''</span>
        <span class="hljs-comment"># 值列表</span>
        self.wordids = wordids
        self.hiddenids = self.getallhiddenids(wordids, urlids)
        self.urlids = urlids

        <span class="hljs-comment"># 节点输出</span>
        self.ai = [<span class="hljs-number">1.0</span>] * len(self.wordids)
        self.ah = [<span class="hljs-number">1.0</span>] * len(self.hiddenids)
        self.ao = [<span class="hljs-number">1.0</span>] * len(self.urlids)

        <span class="hljs-comment"># 建立权重矩阵</span>
        self.wi = [[self.getstrength(wordid, hiddenid, <span class="hljs-number">0</span>)
            <span class="hljs-keyword">for</span> hiddenid <span class="hljs-keyword">in</span> self.hiddenids] 
            <span class="hljs-keyword">for</span> wordid <span class="hljs-keyword">in</span> self.wordids]
        self.wo = [[self.getstrength(hidden, urlid, <span class="hljs-number">1</span>)
            <span class="hljs-keyword">for</span> urlid <span class="hljs-keyword">in</span> self.urlids]
            <span class="hljs-keyword">for</span> hiddenid <span class="hljs-keyword">in</span> self.hiddenids]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">feedforward</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">'''算法接受一列输入，将其推入网络，然后返回所有输出层节点的输出。
        所有来自输入层节点的输出结果都将总是1
        只要持续不断地将上一层的输出作为下一层的输入，我们可以很容易地对网络加以扩展，令其包含更多的层
        '''</span>
        <span class="hljs-comment"># 查询单词是仅有的输入</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(self.wordids)):
            self.ai[i] = <span class="hljs-number">1.0</span>

        <span class="hljs-comment"># 隐藏层节点的活跃程度</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
            sum = <span class="hljs-number">0.0</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(self.wordids)):
                sum = sum + self.ai[i] * self.wi[i][j]
            self.ah[j] = tanh(sum)

        <span class="hljs-comment"># 输出层节点的活跃程度</span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(self.urlids)):
            sum = <span class="hljs-number">0.0</span>
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
                sum = sum + self.ah[j] * self.wo[j][k]
            self.ao[k] = tanh(sum)

        <span class="hljs-keyword">return</span> self.ao[:]

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getresult</span><span class="hljs-params">(self, wordids, urlids)</span>:</span>
        self.setupnetwork(wordids, urlids)
        <span class="hljs-keyword">return</span> self.feedforward()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backPropagate</span><span class="hljs-params">(self, targets, N=<span class="hljs-number">0.5</span>)</span>:</span>
        <span class="hljs-string">'''反向传播，按照正向传播的计算方法，反向传回
        对于输出层中的每个节点：
        1. 计算节点当前输出结果与期望结果之间的差距
        2. 利用dtanh函数确定节点的总输入需要如何改变
        3. 改变每个外部回指链接的强度值，其值与链接的当前强度及学习速率（learning rate）成一定比例
        对于每个隐藏层中的节点：
        1. 将每个输出链接（output link）的强度值乘以其目标节点所需的改变量，在累加求和，从而改变节点的输出结果
        2. 利用dtanh函数确定节点的总输入需要如何改变
        3. 改变每个输入链接（input link）的强度值，其值与链接的当前强度及学习速率成一定比例
        '''</span>
        <span class="hljs-comment"># 计算输出层的误差</span>
        output_deltas = [<span class="hljs-number">0.0</span>] * len(self.urlids)
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(self.urlids)):
            error = targets[k] - self.ao[k]
            output_deltas[k] = dtanh(self.ao[k]) * error

        <span class="hljs-comment"># 计算隐藏层的误差</span>
        hidden_deltas = [<span class="hljs-number">0.0</span>] * len(self.hiddenids)
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
            error = <span class="hljs-number">0.0</span>
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(self.urlids)):
                error = error + output_deltas[k]*self.wo[j][k]
            hidden_deltas[j] = dtanh(self.ah[j]) * error

        <span class="hljs-comment"># 更新输出权重</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(self.urlids)):
                change = output_deltas[k] * self.ah[j]
                self.wo[j][k] = self.wo[j][k] + N * change

        <span class="hljs-comment"># 更新输入权重</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(self.wordids)):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
                change = hidden_deltas[j] * self.ai[i]
                self.wi[i][j] = self.wi[i][j] + N * change

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">trainquery</span><span class="hljs-params">(self, wordids, urlids, selectedurl)</span>:</span>
        <span class="hljs-comment"># 如果必要，生成一个隐藏节点</span>
        self.generatehiddennode(wordids, urlids)

        self.setupnetwork(wordids, urlids)
        self.feedforward()
        targets = [<span class="hljs-number">0.0</span>] * len(urlids)
        targets[urlids.index(selectedurl)] = <span class="hljs-number">1.0</span>
        self.backPropagate(targets)
        self.updatedatabase()

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">updatedatabase</span><span class="hljs-params">(self)</span>:</span>
        <span class="hljs-string">'''将权重信息wi，wo更新到数据库'''</span>
        <span class="hljs-comment"># set them to database values</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(self.wordids)):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
                self.setstrength(self.wordids[i],self. hiddenids[j],<span class="hljs-number">0</span>,self.wi[i][j])
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(self.hiddenids)):
            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(self.urlids)):
                self.setstrength(self.hiddenids[j],self.urlids[k],<span class="hljs-number">1</span>,self.wo[j][k])
        self.con.commit()
</code></pre>
<pre><code class="lang-python"><span class="hljs-keyword">print</span> <span class="hljs-string">'设置数据库'</span>
mynet = searchnet(<span class="hljs-string">'nn.db'</span>)
mynet.maketables()
wWorld, wRiver, wBank = <span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>
uWordBank, uRiver, uEarth = <span class="hljs-number">201</span>, <span class="hljs-number">202</span>, <span class="hljs-number">203</span>
mynet.generatehiddennode([wWorld, wBank], [uWordBank, uRiver, uEarth])
</code></pre>
<h4 id="----feeding-forward">前馈法 -- Feeding Forward</h4>
<p>选择一个函数，用以指示每个节点对输入的响应程度。
反双曲正切变换函数（hyperbolic tangent，tanh）
特点：当输入接近0时，输出便开始快速爬高
      当输入为2时，输出几乎停留在1的位置上不再变化
这是一类S型函数（sigmoid function），所有该类型的函数都会呈现这样的S形状。
神经网络几乎总是利用S型函数来计算神经元的输出</p>
<pre><code>searchnet.getallhiddenids(self, wordids, urlids)
searchnet.setupnetwork(self, wordids, urlids)
searchnet.feedforward(self)
searchnet.getresult(self, wordids, urlids)
</code></pre><h4 id="----training-with-backpropagation">利用反向传播法进行训练 -- Training with Backpropagation</h4>
<p>反向传播法：该算法在调整权重值时是沿着网络反向行进的。</p>
<blockquote>
<p>因为在对网络进行训练时，我们始终都知道每个输出层节点的期望输出，
所以在这种情况下，如果用户点击了预期的结果，则它应该朝着1的方向推进，否则就朝着0的方向推进。</p>
</blockquote>
<p>修改某一节点输出结果的唯一方法，是修改针对该节点的总输入。
那么该如何改变总的输入？ </p>
<blockquote>
<p>训练算法须要知道tanh函数在其当前输出级别上的斜率（slope）。
当输出为0.0时，斜率就会非常的‘陡’，只改变一点点输入就会获得很大的变化
如果输入接近-1或1，则改变输入对输出构成的影响就会变得越来越小。</p>
</blockquote>
<pre><code>sinh(x) = (e**x - e**(-x)) / 2
cosh(x) = (e**x + e**(-x)) / 2
tanh(x) = sinh(x) / cosh(x)
coth(x) = 1 / tanh(x)
sech(x) = 1 / cosh(x)
csch(x) = 1 / sinh(x)
def dtahh(y):
    return 1.0 -y*y

searchnet.backPropagate(self, targets, N=0.5)
searchnet.trainquery(self, wordids, urlids, selectedurl)
searchnet.updatedatabase(self)
</code></pre><h4 id="training-test">Training Test</h4>
<pre><code class="lang-python"><span class="hljs-keyword">print</span> <span class="hljs-string">'training test'</span>
allurls = [uWordBank, uRiver, uEarth]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">30</span>):
    mynet.trainquery([wWorld, wBank], allurls, uWordBank)
    mynet.trainquery([wRiver, wBank], allurls, uRiver)
    mynet.trainquery([wWorld], allurls, uEarth)
</code></pre>
<p>神经网络不仅掌握了URL与查询的联系，还了解到一次特定查询中，哪些单词是重要的 -- 这些信息是单纯从查询与URL的关联关系中无法获取的</p>
<h4 id="connecting-to-the-search-engine">Connecting to the Search Engine</h4>
<p>searcher.nnscore(self, rows, wordids)</p>
<h3 id="exercises">Exercises</h3>
<ol>
<li><strong>分词</strong> separatewords方法目前将任何非字母和非数字字符都当作了分隔符，这意味着它无法为诸如&#39;C++&#39;,&#39;$20&#39;,&#39;Ph.D&#39;,&#39;617-555-1212&#39;这样的词条建立正确的索引。更好的分词方法是什么呢？使用空白符作为分隔符是否可以？请编写一个更好的分词函数</li>
<li><strong>布尔操作符</strong> python OR perl这样的搜索条件。一个OR查询可以通过分别执行两次查询后在对结果进行组合的方式来实现，但是对与&#39;python AND (program OR code)&#39;又该如何处理呢？请修改查询方法以支持某些基本的布尔操作。</li>
<li><strong>精确匹配</strong> 编写一个新的getrows函数，返回顺序必须与查询条件中的单词顺序相同，而且中间不允许夹杂任何其他的单词的精确匹配结果</li>
<li><strong>长文/短文搜索</strong> 编写一个权重函数，该函数将根据传入的参数，倾向与给出较长或较短的文档。如查找有关疑难问题的长篇，或查找命令行工具的快速参考短篇。</li>
<li><strong>单词频度偏好</strong> ‘单词计数’的度量方法更偏向与较长的文档，因为篇幅较长的文档拥有更多的单词，而且因此也更有可能包含要搜索的单词。请编写一个新的度量方法，以文档中单词数量的百分比作为频度进行计算。</li>
<li><strong>外部回指链接搜索</strong> ? 不明白什么意思</li>
<li><strong>不同的训练选项</strong> 对神经网络进行训练时，我们使用的一组0值代表所有用户没有点击的URL，而用1来代表用户点击过的URL。请修改函数，令其能够允许用户对结果给予从1到5的评价 searchnet.trainquery()</li>
<li><strong>附加层</strong> 目前的神经网络只有一个隐藏层。请修改searchnet类， 令其支持任意数量的隐藏层。关于层数，我们可以在初始化时加以指定。 searchnet.generatehiddennode()</li>
</ol>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../../PCI/cap3/cap3.html" class="navigation navigation-prev " aria-label="Previous page: 发现群组"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../../PCI/cap5/cap5.html" class="navigation navigation-next " aria-label="Next page: 优化"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
