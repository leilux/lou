<!DOCTYPE HTML>
<html lang="en-US" >
    
    <head>
        
        <meta charset="UTF-8">
        <title>发现群组 | 机器学习</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 1.1.0">
        <meta name="HandheldFriendly" content="true"/>
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
        <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">
        
    
    
    
    <link rel="next" href="../../PCI/cap4/cap4.html" />
    
    
    <link rel="prev" href="../../PCI/cap2/cap2.html" />
    

        
    </head>
    <body>
        
        
<link rel="stylesheet" href="../../gitbook/style.css">


        
    <div class="book" data-level="1.2" data-basepath="../.." data-revision="1428042646490">
    

<div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Type to search" class="form-control" />
    </div>
    <ul class="summary">
        
    	
    	
    	

        

        
    
        
        <li class="chapter " data-level="0" data-path="index.html">
            
                
                    <a href="../../index.html">
                        <i class="fa fa-check"></i>
                        
                         Introduction
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1" data-path="PCI/readme.html">
            
                
                    <a href="../../PCI/readme.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.</b>
                        
                         集体智慧编程
                    </a>
                
            
            
            <ul class="articles">
                
    
        
        <li class="chapter " data-level="1.1" data-path="PCI/cap2/cap2.html">
            
                
                    <a href="../../PCI/cap2/cap2.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.1.</b>
                        
                         提供推荐
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter active" data-level="1.2" data-path="PCI/cap3/cap3.html">
            
                
                    <a href="../../PCI/cap3/cap3.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.2.</b>
                        
                         发现群组
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.3" data-path="PCI/cap4/cap4.html">
            
                
                    <a href="../../PCI/cap4/cap4.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.3.</b>
                        
                         搜索与排名
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.4" data-path="PCI/cap5/cap5.html">
            
                
                    <a href="../../PCI/cap5/cap5.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.4.</b>
                        
                         优化
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.5" data-path="PCI/cap6/cap6.html">
            
                
                    <a href="../../PCI/cap6/cap6.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.5.</b>
                        
                         文档过滤
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.6" data-path="PCI/cap7/cap7.html">
            
                
                    <a href="../../PCI/cap7/cap7.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.6.</b>
                        
                         决策树建模
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.7" data-path="PCI/cap8/cap8.html">
            
                
                    <a href="../../PCI/cap8/cap8.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.7.</b>
                        
                         构建价格模型
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.8" data-path="PCI/cap9/cap9.html">
            
                
                    <a href="../../PCI/cap9/cap9.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.8.</b>
                        
                         高阶分类：核心方法和SVMs
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.9" data-path="PCI/cap10/cap10.html">
            
                
                    <a href="../../PCI/cap10/cap10.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.9.</b>
                        
                         寻找独立特征
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.10" data-path="PCI/cap11/cap11.html">
            
                
                    <a href="../../PCI/cap11/cap11.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.10.</b>
                        
                         智能进化
                    </a>
                
            
            
        </li>
    
        
        <li class="chapter " data-level="1.11" data-path="PCI/cap12/cap12.html">
            
                
                    <a href="../../PCI/cap12/cap12.html">
                        <i class="fa fa-check"></i>
                        
                            <b>1.11.</b>
                        
                         算法总结
                    </a>
                
            
            
        </li>
    

            </ul>
            
        </li>
    


        
        <li class="divider"></li>
        <li>
            <a href="http://www.gitbook.io/" target="blank" class="gitbook-link">Published using GitBook</a>
        </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="book-header">
    <!-- Actions Left -->
    <a href="#" class="btn pull-left toggle-summary" aria-label="Toggle summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search" aria-label="Toggle search"><i class="fa fa-search"></i></a>
    
    <div id="font-settings-wrapper" class="dropdown pull-left">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle font settings"><i class="fa fa-font"></i>
        </a>
        <div class="dropdown-menu font-settings">
    <div class="dropdown-caret">
        <span class="caret-outer"></span>
        <span class="caret-inner"></span>
    </div>

    <div class="buttons">
        <button type="button" id="reduce-font-size" class="button size-2">A</button>
        <button type="button" id="enlarge-font-size" class="button size-2">A</button>
    </div>

    <div class="buttons font-family-list">
        <button type="button" data-font="0" class="button">Serif</button>
        <button type="button" data-font="1" class="button">Sans</button>
    </div>

    <div class="buttons color-theme-list">
        <button type="button" id="color-theme-preview-0" class="button size-3" data-theme="0">White</button>
        <button type="button" id="color-theme-preview-1" class="button size-3" data-theme="1">Sepia</button>
        <button type="button" id="color-theme-preview-2" class="button size-3" data-theme="2">Night</button>
    </div>
</div>

    </div>

    <!-- Actions Right -->
    
    <div class="dropdown pull-right">
        <a href="#" class="btn toggle-dropdown" aria-label="Toggle share dropdown"><i class="fa fa-share-alt"></i>
        </a>
        <div class="dropdown-menu font-settings dropdown-left">
            <div class="dropdown-caret">
                <span class="caret-outer"></span>
                <span class="caret-inner"></span>
            </div>
            <div class="buttons">
                <button type="button" data-sharing="twitter" class="button">Twitter</button>
                <button type="button" data-sharing="google-plus" class="button">Google</button>
                <button type="button" data-sharing="facebook" class="button">Facebook</button>
                <button type="button" data-sharing="weibo" class="button">Weibo</button>
                <button type="button" data-sharing="instapaper" class="button">Instapaper</button>
            </div>
        </div>
    </div>
    

    
    <a href="#" target="_blank" class="btn pull-right google-plus-sharing-link sharing-link" data-sharing="google-plus" aria-label="Share on Google Plus"><i class="fa fa-google-plus"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right facebook-sharing-link sharing-link" data-sharing="facebook" aria-label="Share on Facebook"><i class="fa fa-facebook"></i></a>
    
    
    <a href="#" target="_blank" class="btn pull-right twitter-sharing-link sharing-link" data-sharing="twitter" aria-label="Share on Twitter"><i class="fa fa-twitter"></i></a>
    
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="../../" >机器学习</a>
    </h1>
</div>

            <div class="page-wrapper" tabindex="-1">
                <div class="page-inner">
                
                
                    <section class="normal" id="section-gitbook_6">
                    
                        <h2 id="----discovering-groups">发现组群 -- Discovering Groups</h2>
<p>数据聚类：一种用以寻找紧密相关的事、人或观点，并将其可视化的方法。</p>
<ol>
<li>从各种不同的来源中构造算法所需的数据</li>
<li>两种不同的聚类算法</li>
<li>更多有关距离度量（distance metrics）的知识</li>
<li>简单的图形可视化代码，用以观察所生成的群组</li>
<li>如何将异常复杂的数据集投影到二维空间中</li>
</ol>
<p>监督学习和无监督学习 -- Supervised versus Unsupervised Learning</p>
<p>监督学习法：利用样本输入和期望输出来学习如何预测的技术
如：神经网络、决策树、支持向量机，及贝叶斯过滤</p>
<p>无监督学习：不是利用带有正确答案的样本数据进行训练。它
            们的目的是要在一组数据中找寻某种结构，而这
            些数据本身并不是我们要找的答案。
如：聚类，负矩阵因式分解，自组织映射</p>
<pre><code class="lang-python"><span class="hljs-comment">##单词向量 -- Word Vectors</span>

<span class="hljs-comment"># 为聚类算法准备数据常见的做法是定义一组公共的数值型属性，可以利用这些属性对数据项进行比较。</span>

<span class="hljs-comment">###对博客用户进行分类 -- Pigeonholing the Bloggers</span>

<span class="hljs-comment"># 根据单词出现的频度对博客进行聚类。</span>

<span class="hljs-comment">###对订阅源中的单词进行计数 -- Counting the Words in a feed</span>

<span class="hljs-comment"># generatefeedvector.py</span>
<span class="hljs-comment">#import feedparser</span>
<span class="hljs-keyword">import</span> re

<span class="hljs-comment"># returns title and dictionary of word counts for an RSS feed</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getwordcounts</span><span class="hljs-params">(url)</span>:</span>
    <span class="hljs-comment"># parse the feed</span>
    d = feedparser.parse(url)
    wc = {}

    <span class="hljs-comment"># loop over all the entries</span>
    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> d.entries:
        summary = e.summary <span class="hljs-keyword">if</span> <span class="hljs-string">'summary'</span> <span class="hljs-keyword">in</span> e <span class="hljs-keyword">else</span>\
                  e.description
        <span class="hljs-comment"># extract a list of words</span>
        words = getwords(e.title+<span class="hljs-string">' '</span>+summary)
        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words:
            wc.setdefault(word, <span class="hljs-number">0</span>)
            wc[word] += <span class="hljs-number">1</span>
    <span class="hljs-keyword">return</span> d.feed.title, wc

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getwords</span><span class="hljs-params">(html)</span>:</span>
    <span class="hljs-comment"># remove all the HTML tags</span>
    txt = re.compile(<span class="hljs-string">r'&lt;[^&gt;]+&gt;'</span>).sub(<span class="hljs-string">''</span>, html)

    <span class="hljs-comment"># split words by all non-alpha characters</span>
    words = re.compile(<span class="hljs-string">r'[^A-Z^a-z]+'</span>).split(txt)

    <span class="hljs-comment"># convert to lowercase</span>
    <span class="hljs-keyword">return</span> [word.lower() <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words <span class="hljs-keyword">if</span> word != <span class="hljs-string">''</span>]

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generatefeedvector</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-string">'''遍历订阅源并生成数据集'''</span>
    <span class="hljs-comment"># 生成针对每个博客的单词统计，及出现这些单词的博客数</span>
    apcount = {}
    wordcounts = {}
    feedlist = [line <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file(<span class="hljs-string">'feedlist.txt'</span>)]
    <span class="hljs-keyword">for</span> feedurl <span class="hljs-keyword">in</span> feedlist:
        title, wc = getwordcounts(feedurl)
        wordcounts[title] = wc
        <span class="hljs-keyword">for</span> word, count <span class="hljs-keyword">in</span> wc.items():
            apcount.setdefault(word, <span class="hljs-number">0</span>)
            <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">1</span>:
                apcount[word] += <span class="hljs-number">1</span>

    <span class="hljs-comment"># 建立一个单词列表，实际用于针对每个博客的单词计数</span>
    <span class="hljs-comment"># 10% ～ 50%</span>
    wordlist = []
    <span class="hljs-keyword">for</span> w, bc <span class="hljs-keyword">in</span> apcount.items():
        frac = float(bc) / len(feedlist)
        <span class="hljs-keyword">if</span> farc &gt; <span class="hljs-number">0.1</span> <span class="hljs-keyword">and</span> farc &lt; <span class="hljs-number">0.5</span>: wordlist.append(w)


    out = file(<span class="hljs-string">'blogdata.txt'</span>, <span class="hljs-string">'w'</span>)
    out.write(<span class="hljs-string">'Blog'</span>)
    <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> wordlist: out.write(<span class="hljs-string">'\t%s'</span> % word)
    out.write(<span class="hljs-string">'\n'</span>)
    <span class="hljs-keyword">for</span> blog, wc <span class="hljs-keyword">in</span> wordcounts.items():
        out.write(blog)
        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> wordlist:
            <span class="hljs-keyword">if</span> word <span class="hljs-keyword">in</span> wc: out.write(<span class="hljs-string">'\t%d'</span> % wc[word])
            <span class="hljs-keyword">else</span>: out.write(<span class="hljs-string">'\t0'</span>)
        out.write(<span class="hljs-string">'\n'</span>)


<span class="hljs-comment">##分级聚类 -- Hierarchical Clustering</span>

<span class="hljs-comment"># 通过连续不断地将最为相似的群组两两合并，来构造出一个群组的层级结构。其中的每个群组都是从单一元素开始的。</span>

<span class="hljs-comment"># 树状图(dendrogram) 分级聚类的一种可视化形式</span>

<span class="hljs-comment"># clusters.py</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">readfile</span><span class="hljs-params">(filename)</span>:</span>
    lines = [line <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> file(filename)]

    <span class="hljs-comment"># first line is column titles</span>
    colnames = lines[<span class="hljs-number">0</span>].strip().split(<span class="hljs-string">'\t'</span>)[<span class="hljs-number">1</span>:]
    rownames = []
    data = []
    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines[<span class="hljs-number">1</span>:]:
        p = line.strip().split(<span class="hljs-string">'\t'</span>)
        <span class="hljs-comment"># first column in each row is the rowname</span>
        rownames.append(p[<span class="hljs-number">0</span>])
        <span class="hljs-comment"># the data for this row is the remainder of the row</span>
        data.append([float(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> p[<span class="hljs-number">1</span>:]])
    <span class="hljs-keyword">return</span> rownames, colnames, data


<span class="hljs-keyword">from</span> math <span class="hljs-keyword">import</span> sqrt

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pearson</span><span class="hljs-params">(v1, v2)</span>:</span>
    <span class="hljs-comment"># simple sums</span>
    sum1 = sum(v1)
    sum2 = sum(v2)

    <span class="hljs-comment"># sums of the squares</span>
    sum1Sq = sum([pow(v,<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> v1])
    sum2Sq = sum([pow(v,<span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> v2])

    <span class="hljs-comment"># sum of the products</span>
    pSum = sum([v1[i]*v2[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(v1))])

    <span class="hljs-comment"># calculate r (Pearson score)</span>
    num = pSum - (sum1*sum2/len(v1))
    den = sqrt((sum1Sq-pow(sum1,<span class="hljs-number">2</span>)/len(v1))*(sum2Sq-pow(sum2,<span class="hljs-number">2</span>)/len(v1)))
    <span class="hljs-keyword">if</span> den == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> - num/den

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">bicluster</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, vec, left=None, right=None, distance=<span class="hljs-number">0.0</span>, id=None)</span>:</span>
        self.left = left
        self.right = right
        self.vec = vec
        self.id = id
        self.distance = distance

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hcluster</span><span class="hljs-params">(rows, distance=pearson)</span>:</span>
    distances = {}
    currentclustid = -<span class="hljs-number">1</span>

    <span class="hljs-comment"># clusters are initially just the rows</span>
    clust = [bicluster(rows[i],id=i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(rows))]

    <span class="hljs-keyword">while</span> len(clust)&gt;<span class="hljs-number">1</span>:
        lowestpair = (<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)
        closest = distance(clust[<span class="hljs-number">0</span>].vec, clust[<span class="hljs-number">1</span>].vec)

        <span class="hljs-comment"># loop through every pair looking for the smallest distance</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(clust)):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>, len(clust)):
                <span class="hljs-comment"># distances is the cache of distance calculations</span>
                <span class="hljs-keyword">if</span> (clust[i].id, clust[j].id) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> distances:
                    distances[(clust[i].id, clust[j].id)] = distance(clust[i].vec, clust[j].vec)
                d = distances[(clust[i].id, clust[j].id)]

                <span class="hljs-keyword">if</span> d &lt; closest:
                    closest = d
                    lowestpair = (i, j)

        <span class="hljs-comment"># calculate the average of the two clusters</span>
        mergevec = [
            (clust[lowestpair[<span class="hljs-number">0</span>]].vec[i]+clust[lowestpair[<span class="hljs-number">1</span>]].vec[i])/<span class="hljs-number">2.0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(clust[<span class="hljs-number">0</span>].vec))]

        <span class="hljs-comment"># create the new cluster</span>
        newcluster = bicluster(mergevec, 
                               left=clust[lowestpair[<span class="hljs-number">0</span>]],
                               right=clust[lowestpair[<span class="hljs-number">1</span>]],
                               distance=closest,
                               id=currentclustid)

        <span class="hljs-comment"># cluster ids that weren't in the original set are negative</span>
        currentclustid -= <span class="hljs-number">1</span>
        <span class="hljs-keyword">del</span> clust[lowestpair[<span class="hljs-number">1</span>]]
        <span class="hljs-keyword">del</span> clust[lowestpair[<span class="hljs-number">0</span>]]
        clust.append(newcluster)

    <span class="hljs-keyword">return</span> clust[<span class="hljs-number">0</span>]


<span class="hljs-comment">#print '调用hcluster方法'</span>
<span class="hljs-comment">#blognames, words, data = readfile('blogdata.txt')</span>
<span class="hljs-comment">#clust = hcluster(data)</span>


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printclust</span><span class="hljs-params">(clust, labels=None, n=<span class="hljs-number">0</span>)</span>:</span>
    <span class="hljs-comment"># indent to make a hierarchy layout</span>
    <span class="hljs-keyword">print</span> <span class="hljs-string">' '</span>*n,
    <span class="hljs-keyword">if</span> clust.id &lt; <span class="hljs-number">0</span>:
        <span class="hljs-comment"># negative id means that this is branch</span>
        <span class="hljs-keyword">print</span> <span class="hljs-string">'-'</span>
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># positive id means that this is an endpoint</span>
        <span class="hljs-keyword">print</span> clust.id <span class="hljs-keyword">if</span> labels==<span class="hljs-keyword">None</span> <span class="hljs-keyword">else</span> labels[clust.id]

    <span class="hljs-comment"># now print the right and left branches</span>
    <span class="hljs-keyword">if</span> clust.left != <span class="hljs-keyword">None</span>: printclust(clust.left, labels=labels, n=n+<span class="hljs-number">1</span>)
    <span class="hljs-keyword">if</span> clust.right!= <span class="hljs-keyword">None</span>: printclust(clust.right, labels=labels, n=n+<span class="hljs-number">1</span>)


<span class="hljs-comment">#print '调用printclust'</span>
<span class="hljs-comment">#printclust(clust, labels=blognames)</span>


<span class="hljs-comment">##绘制树状图 -- Drawing the Dendrogram</span>

<span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageDraw

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getheight</span><span class="hljs-params">(clust)</span>:</span>
    <span class="hljs-comment"># is this an endpoint? then the height is just 1</span>
    <span class="hljs-keyword">if</span> clust.left == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> clust.right == <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>

    <span class="hljs-comment"># otherwise the height is the same of the heights of</span>
    <span class="hljs-comment"># each branch</span>
    <span class="hljs-keyword">return</span> getheight(clust.left) + getheight(clust.right)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getdepth</span><span class="hljs-params">(clust)</span>:</span>
    <span class="hljs-comment"># the distance of an endpoint is 0.0</span>
    <span class="hljs-keyword">if</span> clust.left == <span class="hljs-keyword">None</span> <span class="hljs-keyword">and</span> clust.right == <span class="hljs-keyword">None</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>

    <span class="hljs-comment"># the distance of branch is the greater of its two sides</span>
    <span class="hljs-comment"># plus its own distance</span>
    <span class="hljs-keyword">return</span> max(getdepth(clust.left), getdepth(clust.right)) + clust.distance


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawdendrogram</span><span class="hljs-params">(clust, labels, jpeg=<span class="hljs-string">'clusters.jpg'</span>)</span>:</span>
    <span class="hljs-comment"># height and width</span>
    h = getheight(clust) * <span class="hljs-number">20</span>
    w = <span class="hljs-number">1200</span>
    depth = getdepth(clust)

    <span class="hljs-comment"># width is fixed, so scale distances accordingly</span>
    scaling = float(w-<span class="hljs-number">150</span>)/depth

    <span class="hljs-comment"># create a new image with a white background</span>
    img = Image.new(<span class="hljs-string">'RGB'</span>, (w,h), (<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))
    draw = ImageDraw.Draw(img)

    draw.line((<span class="hljs-number">0</span>, h/<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, h/<span class="hljs-number">2</span>), fill=(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))

    <span class="hljs-comment"># draw the first node</span>
    drawnode(draw, clust, <span class="hljs-number">10</span>, (h/<span class="hljs-number">2</span>), scaling, labels)
    img.save(jpeg, <span class="hljs-string">'JPEG'</span>)


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawnode</span><span class="hljs-params">(draw, clust, x, y, scaling, labels)</span>:</span>
    <span class="hljs-keyword">if</span> clust.id &lt; <span class="hljs-number">0</span>:
        h1 = getheight(clust.left)*<span class="hljs-number">20</span>
        h2 = getheight(clust.right)*<span class="hljs-number">20</span>
        top = y - (h1 + h2)/<span class="hljs-number">2</span>
        bottom = y + (h1 + h2)/<span class="hljs-number">2</span>
        <span class="hljs-comment"># line length</span>
        ll = clust.distance * scaling
        <span class="hljs-comment"># vertical line from this cluster to children</span>
        draw.line((x, top+h1/<span class="hljs-number">2</span>, x, bottom-h2/<span class="hljs-number">2</span>), fill=(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))

        <span class="hljs-comment"># horizontal line to left item</span>
        draw.line((x, top+h1/<span class="hljs-number">2</span>, x+ll, top+h1/<span class="hljs-number">2</span>), fill=(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))

        <span class="hljs-comment"># horizontal line to right item</span>
        draw.line((x, bottom-h2/<span class="hljs-number">2</span>, x+ll, bottom-h2/<span class="hljs-number">2</span>), fill=(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))

        <span class="hljs-comment"># call the function to draw the left and right nodes</span>
        drawnode(draw, clust.left, x+ll, top+h1/<span class="hljs-number">2</span>, scaling, labels)
        drawnode(draw, clust.right, x+ll, bottom-h2/<span class="hljs-number">2</span>, scaling, labels)
    <span class="hljs-keyword">else</span>:
        <span class="hljs-comment"># if this is an endpoint, draw the item label</span>
        draw.text((x+<span class="hljs-number">5</span>,y-<span class="hljs-number">7</span>), labels[clust.id], (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))

<span class="hljs-comment">#print '生成图片'</span>
<span class="hljs-comment">#drawdendrogram(clust, blognames, jpeg='blogclust.jpg')</span>

<span class="hljs-comment">##列聚类 -- Column Clustering</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotatematrix</span><span class="hljs-params">(data)</span>:</span>
    <span class="hljs-string">'''使data的每行表示某个单词在每篇博客中出现的次数'''</span>
    newdata = []
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(data[<span class="hljs-number">0</span>])):
        newrow = [data[j][i] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(data))]
        newdata.append(newrow)
    <span class="hljs-keyword">return</span> newdata

<span class="hljs-comment">#print '列聚类 -- 画图'</span>
<span class="hljs-comment">#rdata = rotatematrix(data)</span>
<span class="hljs-comment">#wordclust = hcluster(rdata)</span>
<span class="hljs-comment">#drawdendrogram(wordclust, labels=words, jpeg='wordclust.jpg')</span>

<span class="hljs-comment"># 聚类有一点很重要：当数据项的数量比变量多的时候，出现无意义的聚类的可能性就会增加?</span>
<span class="hljs-comment"># 单词聚类：显示了，人们在博客中探讨在线服务或与Internect相关的话题时，经常会用到的一组词汇。</span>
<span class="hljs-comment"># 我们可能会找到一些反映使用模式（usage patterns）的聚类，如fact，us，say，very及think，这些单词说明博客的写作风格是偏主观的（opinionated）</span>

<span class="hljs-comment"># 分级聚类的缺点：</span>
<span class="hljs-comment"># 1. 在没有额外投入的情况下，树形视图是不会真正将数据拆分成不同组的</span>
<span class="hljs-comment"># 2. 该算法的计算量非常惊人 n**2 - n - 1 = O(n**2)</span>

<span class="hljs-comment">##K-均值聚类 -- K-Means Clustering</span>

<span class="hljs-comment"># K-均值聚类：预先告诉算法希望生成的聚类数量，然后算法会根据数据的结构状况来确定聚类的大小。</span>
<span class="hljs-comment"># 首先会随机确定k个中心位置（位于空间中代表聚类中心的点）# 然后将各个数据项分配给最临近的中心点。</span>
<span class="hljs-comment"># 分配完成后，聚类的中心会移到分配给该聚类的所有节点的平均位置处</span>
<span class="hljs-comment"># 整个分配过程重新开始，一致重复，直到分配过程不再产生变化为止。</span>

<span class="hljs-keyword">import</span> random

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">kcluster</span><span class="hljs-params">(rows, distance=pearson, k=<span class="hljs-number">4</span>)</span>:</span>
    <span class="hljs-comment"># determine the minimum and maximum values for each point</span>
    ranges = [(min([row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows]), max([row[i] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> rows])) 
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(rows[<span class="hljs-number">0</span>]))]

    <span class="hljs-comment"># create k randomly placed centroids</span>
    clusters = [[random.random()*(ranges[i][<span class="hljs-number">1</span>] -ranges[i][<span class="hljs-number">0</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(rows[<span class="hljs-number">0</span>]))] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(k)]

    lastmatches = <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>):
        <span class="hljs-keyword">print</span> <span class="hljs-string">'Iteration %d'</span> % t
        bestmatches = [[] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k)]

        <span class="hljs-comment"># find which centroid is the closet for each row</span>
        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(rows)):
            row = rows[j]
            bestmatch = <span class="hljs-number">0</span>
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):
                d = distance(clusters[i], row)
                <span class="hljs-keyword">if</span> d &lt; distance(clusters[bestmatch], row): 
                    bestmatch = i
            bestmatches[bestmatch].append(j)

        <span class="hljs-comment"># if the results are the same as last time, this is complete</span>
        <span class="hljs-keyword">if</span> bestmatches == lastmatches: <span class="hljs-keyword">break</span>
        lastmatches = bestmatches

        <span class="hljs-comment"># move the cetroids to the average of their members</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(k):
            avgs = [<span class="hljs-number">0.0</span>] * len(rows[<span class="hljs-number">0</span>])
            <span class="hljs-keyword">if</span> len(bestmatches[i]) &gt; <span class="hljs-number">0</span>:
                <span class="hljs-keyword">for</span> rowid <span class="hljs-keyword">in</span> bestmatches[i]:
                    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(len(rows[rowid])):
                        avgs[m] += rows[rowid][m]
                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(avgs)):
                    avgs[j] /= len(bestmatches[i])
                clusters[i] = avgs

    <span class="hljs-keyword">return</span> bestmatches

<span class="hljs-comment">#print 'k-means'</span>
<span class="hljs-comment">#kclust = kcluster(data, k=10)</span>
<span class="hljs-comment">#print [blognames[r] for r in kclust[0]]</span>

<span class="hljs-comment">##针对偏好的聚类 -- Clusters of Preferences</span>

<span class="hljs-comment">###获取数据和准备数据 -- Getting and Perparing the Data</span>

<span class="hljs-comment">###Beautiful Soup</span>

<span class="hljs-comment">###收集来自Zebo的结果 -- Scraping the Zebo Results</span>

<span class="hljs-comment"># downloadzebodata.py</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">downloadzebodata</span><span class="hljs-params">()</span>:</span>
    <span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup
    <span class="hljs-keyword">import</span> urllib2
    <span class="hljs-keyword">import</span> re
    chare = re.compile(<span class="hljs-string">r'[!-\.&amp;]'</span>)
    itemowners = {}

    <span class="hljs-comment"># words to remove</span>
    dropwords = [<span class="hljs-string">'a'</span>,<span class="hljs-string">'new'</span>,<span class="hljs-string">'some'</span>,<span class="hljs-string">'more'</span>,<span class="hljs-string">'my'</span>,<span class="hljs-string">'own'</span>,<span class="hljs-string">'the'</span>,<span class="hljs-string">'many'</span>,<span class="hljs-string">'other'</span>,<span class="hljs-string">'another'</span>]

    currentuser = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">51</span>):
        <span class="hljs-comment"># url for the want search page</span>
        c = urllib2.urlopen(
            <span class="hljs-string">'http://member.zebo.com/Main?event_key=USERSEARCH&amp;wiowiw=wiw&amp;keyword=car&amp;page=%d'</span>%(i))
        soup = BeautifulSoup(c.read())
        <span class="hljs-keyword">for</span> td <span class="hljs-keyword">in</span> soup(<span class="hljs-string">'td'</span>):
            <span class="hljs-comment"># find the table cells of bgverdanasmall class</span>
            <span class="hljs-keyword">if</span> (<span class="hljs-string">'class'</span> <span class="hljs-keyword">in</span> dict(td.attrs) <span class="hljs-keyword">and</span> td[<span class="hljs-string">'class'</span>] == <span class="hljs-string">'bgverdanasmall'</span>):
                items = [re.sub(chare, <span class="hljs-string">''</span>, a.contents[<span class="hljs-number">0</span>].lower()).strip() <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> td(<span class="hljs-string">'a'</span>)]
                <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:
                    <span class="hljs-comment"># remove extra words</span>
                    txt = <span class="hljs-string">' '</span>.join([t <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> item.split(<span class="hljs-string">' '</span>) <span class="hljs-keyword">if</span> t <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dropwords])
                    <span class="hljs-keyword">if</span> len(txt) &lt; <span class="hljs-number">2</span>: <span class="hljs-keyword">continue</span>
                    itemowners.setdefault(txt, {})
                    itemowners[txt][currentuser] = <span class="hljs-number">1</span>
                currentuser += <span class="hljs-number">1</span>

    out = file(<span class="hljs-string">'zebo.txt'</span>, <span class="hljs-string">'w'</span>)
    out.write(<span class="hljs-string">'Item'</span>)
    <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, currentuser): out.write(<span class="hljs-string">'\tU%d'</span> % user)
    out.write(<span class="hljs-string">'\n'</span>)
    <span class="hljs-keyword">for</span> item, owners <span class="hljs-keyword">in</span> itemowners.items():
        <span class="hljs-keyword">if</span> len(owners) &gt; <span class="hljs-number">10</span>:
            out.write(item)
            <span class="hljs-keyword">for</span> user <span class="hljs-keyword">in</span> rnage(<span class="hljs-number">0</span>, currentuser):
                <span class="hljs-keyword">if</span> user <span class="hljs-keyword">in</span> owners: out.write(<span class="hljs-string">'\t1'</span>)
                <span class="hljs-keyword">else</span>: out.write(<span class="hljs-string">'\t0'</span>)
            out.write(<span class="hljs-string">'\n'</span>)


<span class="hljs-comment">###定义距离度量标准 -- Defining a Distance Metric</span>

<span class="hljs-comment"># tanimoto系数（tonimoto coefficient）：它代表的是交集与并集的比率</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tanimoto</span><span class="hljs-params">(v1, v2)</span>:</span>
    c1, c2, shr = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>

    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(v1)):
        <span class="hljs-keyword">if</span> v1[i] != <span class="hljs-number">0</span>: c1 += <span class="hljs-number">1</span> <span class="hljs-comment"># in v1</span>
        <span class="hljs-keyword">if</span> v2[i] != <span class="hljs-number">0</span>: c2 += <span class="hljs-number">1</span> <span class="hljs-comment"># in v2</span>
        <span class="hljs-keyword">if</span> v1[i] != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> v2[i] != <span class="hljs-number">0</span>: shr += <span class="hljs-number">1</span> <span class="hljs-comment"># in both</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> - (float(shr)/(c1+c2-shr))


<span class="hljs-comment">###对结果进行聚类 -- Clustering Results</span>

<span class="hljs-comment">#wants, people, data = readfile('zebo.txt')</span>
<span class="hljs-comment">#clust = hcluster(data, distance=tanimoto)</span>
<span class="hljs-comment">#drawdendrogram(clust, wants)</span>

<span class="hljs-comment">##以二维形式展现数据 -- Viewing Data in Two Dimensions</span>

<span class="hljs-comment"># 多维缩放（multidimensional scaling）：为数据集找到一种二维表达形式</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">scaledown</span><span class="hljs-params">(data, distance=pearson, rate=<span class="hljs-number">0.01</span>)</span>:</span>
    n = len(data)

    <span class="hljs-comment"># 每一对数据项之间的真实距离</span>
    realdist = [[distance(data[i], data[j]) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n)]

    outersum = <span class="hljs-number">0.0</span>

    <span class="hljs-comment">#随机初始化节点在二维空间中的起始位置</span>
    loc = [[random.random(), random.random()] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]
    fakedist = [[<span class="hljs-number">0.0</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]

    lasterror = <span class="hljs-keyword">None</span>
    <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>):
        <span class="hljs-comment"># 寻找投影后的距离</span>
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):
                fakedist[i][j] = sqrt(sum([pow(loc[i][x]-loc[j][x], <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(len(loc[i]))]))
        <span class="hljs-comment"># 移动节点</span>
        grad = [[<span class="hljs-number">0.0</span>,<span class="hljs-number">0.0</span>] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]

        totalerror = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(n):
            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):
                <span class="hljs-keyword">if</span> j == k: <span class="hljs-keyword">continue</span>
                <span class="hljs-comment"># 误差值等于目标距离与当前距离之间差值的百分比</span>
                errorterm = (fakedist[j][k]-realdist[j][k])/realdist[j][k]
                <span class="hljs-comment"># 每一个节点都需要根据误差的多少，按比例移离或移向其他节点</span>
                grad[k][<span class="hljs-number">0</span>] += ((loc[k][<span class="hljs-number">0</span>]-loc[j][<span class="hljs-number">0</span>])/fakedist[j][k])*errorterm
                grad[k][<span class="hljs-number">1</span>] += ((loc[k][<span class="hljs-number">1</span>]-loc[j][<span class="hljs-number">1</span>])/fakedist[j][k])*errorterm
                <span class="hljs-comment"># 记录总的误差值</span>
                totalerror += abs(errorterm)
        <span class="hljs-keyword">print</span> totalerror

        <span class="hljs-comment"># 如果节点移动之后的情况变得更糟，则程序结束</span>
        <span class="hljs-keyword">if</span> lasterror <span class="hljs-keyword">and</span> lasterror &lt; totalerror: <span class="hljs-keyword">break</span>
        lasterror = totalerror

        <span class="hljs-comment"># 根据rate参数与grad值相乘的结果，移动每一个节点</span>
        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(n):
            loc[k][<span class="hljs-number">0</span>] -= rate*grad[k][<span class="hljs-number">0</span>]
            loc[k][<span class="hljs-number">1</span>] -= rate*grad[k][<span class="hljs-number">1</span>]

    <span class="hljs-keyword">return</span> loc


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">draw2d</span><span class="hljs-params">(data, labels, jpeg=<span class="hljs-string">'mds2d.jpg'</span>)</span>:</span>
    img = Image.new(<span class="hljs-string">'RGB'</span>, (<span class="hljs-number">2000</span>,<span class="hljs-number">2000</span>), (<span class="hljs-number">255</span>,<span class="hljs-number">255</span>,<span class="hljs-number">255</span>))
    draw = ImageDraw.Draw(img)
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(data)):
        x = (data[i][<span class="hljs-number">0</span>] + <span class="hljs-number">0.5</span>) * <span class="hljs-number">1000</span>
        y = (data[i][<span class="hljs-number">1</span>] + <span class="hljs-number">0.5</span>) * <span class="hljs-number">1000</span>
        draw.text((x,y), labels[i], (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))
    img.save(jpeg, <span class="hljs-string">'JPEG'</span>)

<span class="hljs-comment">#print '二维形式展现数据'</span>
<span class="hljs-comment">#blognames, words, data = readfile('blogdata.txt')</span>
<span class="hljs-comment">#coords = scaledown(data)</span>
<span class="hljs-comment">#draw2d(coords, blognames, jpeg='blogs2d.jpg')</span>
</code></pre>
<h2 id="----other-things-to-cluster">有关聚类的其他事宜 -- Other Things to Cluster</h2>
<h2 id="exercises">Exercises</h2>
<ol>
<li>利用第2章中的del.icio.us API，构造一个适合聚类的标签数据集 针对该数据集分别运行分级聚类算法和K-均值聚类算法 </li>
<li>请修改解析博客的代码，以实现针对每个文章条目（entries）而非整个博客的聚类 来自同一博客的不同条目能否聚类在一起？拥有相同日期信息的条目又如何？</li>
<li>请尝试使用实际距离，（即毕达哥拉斯距离）对博客进行聚类 这样会对结果产生什么样的影响呢？</li>
<li>找到曼哈顿（manhattan）距离的定义 为其编写一个函数，看看它是如何影响Zebo数据集的结果的。</li>
<li>请修改K-均值聚类函数 令其在返回聚类结果的同时，一并返回所有数据项彼此之间的距离总和，以及它们各自的中心点位置</li>
<li>待完成第5个练习之后 请编写一个函数，令其选择不同的k值来运行K-均值聚类算法 看一看总的距离值是如何随着聚类数量的增加而改变的？当处于哪个位置的时候，聚类数的多少对最终结果的影响才会变得微乎其微？</li>
<li>在两个维度上的多维缩放易于打印 不过这项技术也可以用于任意数量的维度。请尝试修改代码，以实现在一个维度上的缩放（即所有点都在一条直线上）。再尝试令其支持三个维度。</li>
</ol>

                    
                    </section>
                
                
                </div>
            </div>
        </div>

        
        <a href="../../PCI/cap2/cap2.html" class="navigation navigation-prev " aria-label="Previous page: 提供推荐"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../../PCI/cap4/cap4.html" class="navigation navigation-next " aria-label="Next page: 搜索与排名"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
<script src="../../gitbook/app.js"></script>

    
    <script src="https://cdn.mathjax.org/mathjax/2.4-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

    
    <script src="../../gitbook/plugins/gitbook-plugin-mathjax/plugin.js"></script>
    

<script>
require(["gitbook"], function(gitbook) {
    var config = {"fontSettings":{"theme":null,"family":"sans","size":2}};
    gitbook.start(config);
});
</script>

        
    </body>
    
</html>
